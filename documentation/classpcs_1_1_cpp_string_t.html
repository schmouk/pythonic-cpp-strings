<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" lang="en-US">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=11"/>
<meta name="generator" content="Doxygen 1.14.0"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>cpp-strings: pcs::CppStringT&lt; CharT, TraitsT, AllocatorT &gt; Class Template Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<script type="text/javascript" src="clipboard.js"></script>
<link href="navtree.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="navtreedata.js"></script>
<script type="text/javascript" src="navtree.js"></script>
<script type="text/javascript" src="cookie.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr id="projectrow">
  <td id="projectalign">
   <div id="projectname">cpp-strings<span id="projectnumber">&#160;1.0.4</span>
   </div>
   <div id="projectbrief">Pythonic c++ strings</div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.14.0 -->
<script type="text/javascript">
var searchBox = new SearchBox("searchBox", "search/",'.html');
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
$(function() {
  initMenu('',true,false,'search.php','Search',true);
  $(function() { init_search(); });
});
</script>
<div id="main-nav"></div>
</div><!-- top -->
<div id="side-nav" class="ui-resizable side-nav-resizable">
  <div id="nav-tree">
    <div id="nav-tree-contents">
      <div id="nav-sync" class="sync"></div>
    </div>
  </div>
  <div id="splitbar" style="-moz-user-select:none;" 
       class="ui-resizable-handle">
  </div>
</div>
<script type="text/javascript">
$(function(){initNavTree('classpcs_1_1_cpp_string_t.html','','classpcs_1_1_cpp_string_t-members'); });
</script>
<div id="container">
<div id="doc-content">
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<div id="MSearchResults">
<div class="SRPage">
<div id="SRIndex">
<div id="SRResults"></div>
<div class="SRStatus" id="Loading">Loading...</div>
<div class="SRStatus" id="Searching">Searching...</div>
<div class="SRStatus" id="NoMatches">No Matches</div>
</div>
</div>
</div>
</div>

<div class="header">
  <div class="headertitle"><div class="title">pcs::CppStringT&lt; CharT, TraitsT, AllocatorT &gt; Class Template Reference</div></div>
</div><!--header-->
<div class="contents">

<p>This is the templated base class for all <a class="el" href="namespacepcs.html#a08d21c458d61442667df24212920d0d9" title="Specialization of basic class with template argument &#39;char&#39;.">CppString</a> classes.  
 <a href="#details">More...</a></p>

<p><code>#include &lt;cppstrings.h&gt;</code></p>
<div class="dynheader">
Inheritance diagram for pcs::CppStringT&lt; CharT, TraitsT, AllocatorT &gt;:</div>
<div class="dyncontent">
 <div class="center">
  <img src="classpcs_1_1_cpp_string_t.png" alt=""/>
 </div></div>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 id="header-nested-classes" class="groupheader"><a id="nested-classes" name="nested-classes"></a>
Classes</h2></td></tr>
<tr class="memitem:NotFoundException" id="r_NotFoundException"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpcs_1_1_cpp_string_t_1_1_not_found_exception.html">NotFoundException</a></td></tr>
<tr class="memitem:TransTable" id="r_TransTable"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpcs_1_1_cpp_string_t_1_1_trans_table.html">TransTable</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">The internal class of translation tables, used with methods CppStringT::maketrans and <a class="el" href="#a2a8c1e78b93da9a0abe471c7a8d85090" title="Returns a copy of the string in which each character has been mapped through the given translation ta...">CppStringT::translate</a>.  <a href="classpcs_1_1_cpp_string_t_1_1_trans_table.html#details">More...</a><br /></td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 id="header-pub-types" class="groupheader"><a id="pub-types" name="pub-types"></a>
Public Types</h2></td></tr>
<tr class="memitem:ad64da5e5c9576bc3a52bf831e1c6406d" id="r_ad64da5e5c9576bc3a52bf831e1c6406d"><td class="memItemLeft" align="right" valign="top"><a id="ad64da5e5c9576bc3a52bf831e1c6406d" name="ad64da5e5c9576bc3a52bf831e1c6406d"></a>
using&#160;</td><td class="memItemRight" valign="bottom"><b>allocator_type</b> = MyBaseClass::allocator_type</td></tr>
<tr class="memitem:a7f7c41a62bad3d4512c3f8a1b490c61e" id="r_a7f7c41a62bad3d4512c3f8a1b490c61e"><td class="memItemLeft" align="right" valign="top"><a id="a7f7c41a62bad3d4512c3f8a1b490c61e" name="a7f7c41a62bad3d4512c3f8a1b490c61e"></a>
using&#160;</td><td class="memItemRight" valign="bottom"><b>const_iterator</b> = MyBaseClass::const_iterator</td></tr>
<tr class="memitem:a173b6f2a0dac89545a5e511cf112366e" id="r_a173b6f2a0dac89545a5e511cf112366e"><td class="memItemLeft" align="right" valign="top"><a id="a173b6f2a0dac89545a5e511cf112366e" name="a173b6f2a0dac89545a5e511cf112366e"></a>
using&#160;</td><td class="memItemRight" valign="bottom"><b>const_pointer</b> = MyBaseClass::const_pointer</td></tr>
<tr class="memitem:ae0372af468359d49be6a64770cd7b4dd" id="r_ae0372af468359d49be6a64770cd7b4dd"><td class="memItemLeft" align="right" valign="top"><a id="ae0372af468359d49be6a64770cd7b4dd" name="ae0372af468359d49be6a64770cd7b4dd"></a>
using&#160;</td><td class="memItemRight" valign="bottom"><b>const_reference</b> = MyBaseClass::const_reference</td></tr>
<tr class="memitem:a9da0b62fc23215e0967868f805103b29" id="r_a9da0b62fc23215e0967868f805103b29"><td class="memItemLeft" align="right" valign="top"><a id="a9da0b62fc23215e0967868f805103b29" name="a9da0b62fc23215e0967868f805103b29"></a>
using&#160;</td><td class="memItemRight" valign="bottom"><b>const_reverse_iterator</b> = MyBaseClass::const_reverse_iterator</td></tr>
<tr class="memitem:aa9b9666ad0bd8e232a4b84dd86a27d63" id="r_aa9b9666ad0bd8e232a4b84dd86a27d63"><td class="memItemLeft" align="right" valign="top"><a id="aa9b9666ad0bd8e232a4b84dd86a27d63" name="aa9b9666ad0bd8e232a4b84dd86a27d63"></a>
using&#160;</td><td class="memItemRight" valign="bottom"><b>difference_type</b> = MyBaseClass::difference_type</td></tr>
<tr class="memitem:a6eef39869a5e148a3d128d08567276d9" id="r_a6eef39869a5e148a3d128d08567276d9"><td class="memItemLeft" align="right" valign="top"><a id="a6eef39869a5e148a3d128d08567276d9" name="a6eef39869a5e148a3d128d08567276d9"></a>
using&#160;</td><td class="memItemRight" valign="bottom"><b>iterator</b> = MyBaseClass::iterator</td></tr>
<tr class="memitem:af0aab237e90011576ef4e29d33b02abb" id="r_af0aab237e90011576ef4e29d33b02abb"><td class="memItemLeft" align="right" valign="top"><a id="af0aab237e90011576ef4e29d33b02abb" name="af0aab237e90011576ef4e29d33b02abb"></a>
using&#160;</td><td class="memItemRight" valign="bottom"><b>MyBaseClass</b> = std::basic_string&lt;CharT, TraitsT, AllocatorT&gt;</td></tr>
<tr class="memitem:aea1279899c7c2ec02bef939d72f2f558" id="r_aea1279899c7c2ec02bef939d72f2f558"><td class="memItemLeft" align="right" valign="top"><a id="aea1279899c7c2ec02bef939d72f2f558" name="aea1279899c7c2ec02bef939d72f2f558"></a>
using&#160;</td><td class="memItemRight" valign="bottom"><b>pointer</b> = MyBaseClass::pointer</td></tr>
<tr class="memitem:a42702725610137e9a7abe46754886f33" id="r_a42702725610137e9a7abe46754886f33"><td class="memItemLeft" align="right" valign="top"><a id="a42702725610137e9a7abe46754886f33" name="a42702725610137e9a7abe46754886f33"></a>
using&#160;</td><td class="memItemRight" valign="bottom"><b>reference</b> = MyBaseClass::reference</td></tr>
<tr class="memitem:a18d0d0b6f03a002d090cf9240bd512c8" id="r_a18d0d0b6f03a002d090cf9240bd512c8"><td class="memItemLeft" align="right" valign="top"><a id="a18d0d0b6f03a002d090cf9240bd512c8" name="a18d0d0b6f03a002d090cf9240bd512c8"></a>
using&#160;</td><td class="memItemRight" valign="bottom"><b>reverse_iterator</b> = MyBaseClass::reverse_iterator</td></tr>
<tr class="memitem:a480e1d9d65af52a64d4dccb6fc3b46e1" id="r_a480e1d9d65af52a64d4dccb6fc3b46e1"><td class="memItemLeft" align="right" valign="top"><a id="a480e1d9d65af52a64d4dccb6fc3b46e1" name="a480e1d9d65af52a64d4dccb6fc3b46e1"></a>
using&#160;</td><td class="memItemRight" valign="bottom"><b>size_type</b> = MyBaseClass::size_type</td></tr>
<tr class="memitem:a11f58fce7365449f1d85bb7e3e18c5f0" id="r_a11f58fce7365449f1d85bb7e3e18c5f0"><td class="memItemLeft" align="right" valign="top"><a id="a11f58fce7365449f1d85bb7e3e18c5f0" name="a11f58fce7365449f1d85bb7e3e18c5f0"></a>
using&#160;</td><td class="memItemRight" valign="bottom"><b>traits_type</b> = MyBaseClass::traits_type</td></tr>
<tr class="memitem:ab9b6996246a0b4e0610019d86dad1538" id="r_ab9b6996246a0b4e0610019d86dad1538"><td class="memItemLeft" align="right" valign="top"><a id="ab9b6996246a0b4e0610019d86dad1538" name="ab9b6996246a0b4e0610019d86dad1538"></a>
using&#160;</td><td class="memItemRight" valign="bottom"><b>value_type</b> = MyBaseClass::value_type</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 id="header-pub-methods" class="groupheader"><a id="pub-methods" name="pub-methods"></a>
Public Member Functions</h2></td></tr>
<tr class="memitem:a48a00cca031b9c29d1912508e120a5f6" id="r_a48a00cca031b9c29d1912508e120a5f6"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classpcs_1_1_cpp_string_t.html">CppStringT</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a48a00cca031b9c29d1912508e120a5f6">capitalize</a> () noexcept</td></tr>
<tr class="memdesc:a48a00cca031b9c29d1912508e120a5f6"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns a copy of the string with its first character capitalized and the rest lowercased.  <br /></td></tr>
<tr class="memitem:af18311d8608e71627bc85f96581e4dd3" id="r_af18311d8608e71627bc85f96581e4dd3"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classpcs_1_1_cpp_string_t.html">CppStringT</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#af18311d8608e71627bc85f96581e4dd3">center</a> (const size_type width, const value_type fillch=value_type(' ')) const noexcept</td></tr>
<tr class="memdesc:af18311d8608e71627bc85f96581e4dd3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns a copy of the string centered in a string of length width.  <br /></td></tr>
<tr class="memitem:a0674e29327353aabf83d0e207fed31ed" id="r_a0674e29327353aabf83d0e207fed31ed"><td class="memItemLeft" align="right" valign="top">constexpr bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a0674e29327353aabf83d0e207fed31ed">contains</a> (const <a class="el" href="classpcs_1_1_cpp_string_t.html">CppStringT</a> &amp;<a class="el" href="#a9debc70420a3fbc7722e3111aeccd819">substr</a>) const noexcept</td></tr>
<tr class="memdesc:a0674e29327353aabf83d0e207fed31ed"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns true if this string contains the passed string, or false otherwise.  <br /></td></tr>
<tr class="memitem:a031b05f290f589b2df52bb84252c27c7" id="r_a031b05f290f589b2df52bb84252c27c7"><td class="memItemLeft" align="right" valign="top">constexpr bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a031b05f290f589b2df52bb84252c27c7">contains_n</a> (const <a class="el" href="classpcs_1_1_cpp_string_t.html">CppStringT</a> &amp;sub, const size_type start, const size_type <a class="el" href="#a7beda74b4d5092845a970d51d01fe4bf">count</a>=-1) const noexcept</td></tr>
<tr class="memdesc:a031b05f290f589b2df52bb84252c27c7"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns true if the passed string is found within the slice str[start:start+count-1], or false otherwise.  <br /></td></tr>
<tr class="memitem:a7beda74b4d5092845a970d51d01fe4bf" id="r_a7beda74b4d5092845a970d51d01fe4bf"><td class="memItemLeft" align="right" valign="top">constexpr size_type&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a7beda74b4d5092845a970d51d01fe4bf">count</a> (const <a class="el" href="classpcs_1_1_cpp_string_t.html">CppStringT</a> &amp;sub, const size_type start=0, const size_type end=-1) const noexcept</td></tr>
<tr class="memdesc:a7beda74b4d5092845a970d51d01fe4bf"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the number of non-overlapping occurrences of substring sub in the range [start, end].  <br /></td></tr>
<tr class="memitem:a59839e3b5a186c2554224dbf4528c1b4" id="r_a59839e3b5a186c2554224dbf4528c1b4"><td class="memItemLeft" align="right" valign="top">constexpr size_type&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a59839e3b5a186c2554224dbf4528c1b4">count_n</a> (const <a class="el" href="classpcs_1_1_cpp_string_t.html">CppStringT</a> &amp;sub, const size_type length) const noexcept</td></tr>
<tr class="memdesc:a59839e3b5a186c2554224dbf4528c1b4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the number of non-overlapping occurrences of substring sub in the range [0, length-1].  <br /></td></tr>
<tr class="memitem:a76f97d56e1713182d5e85d58cd445d10" id="r_a76f97d56e1713182d5e85d58cd445d10"><td class="memItemLeft" align="right" valign="top">constexpr size_type&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a76f97d56e1713182d5e85d58cd445d10">count_n</a> (const <a class="el" href="classpcs_1_1_cpp_string_t.html">CppStringT</a> &amp;sub, const size_type start, const size_type length) const noexcept</td></tr>
<tr class="memdesc:a76f97d56e1713182d5e85d58cd445d10"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the number of non-overlapping occurrences of substring sub in the range [start, start+length-1].  <br /></td></tr>
<tr class="memitem:ae0f62d17727891227088c606a14a4386" id="r_ae0f62d17727891227088c606a14a4386"><td class="memItemLeft" align="right" valign="top"><a id="ae0f62d17727891227088c606a14a4386" name="ae0f62d17727891227088c606a14a4386"></a>
&#160;</td><td class="memItemRight" valign="bottom"><b>CppStringT</b> (const CharT *s)</td></tr>
<tr class="memitem:a7e629e8b9c7a63cab0abfd92e3868707" id="r_a7e629e8b9c7a63cab0abfd92e3868707"><td class="memItemLeft" align="right" valign="top"><a id="a7e629e8b9c7a63cab0abfd92e3868707" name="a7e629e8b9c7a63cab0abfd92e3868707"></a>
&#160;</td><td class="memItemRight" valign="bottom"><b>CppStringT</b> (const CharT *s, size_type <a class="el" href="#a7beda74b4d5092845a970d51d01fe4bf">count</a>)</td></tr>
<tr class="memitem:a76f4400d1f6375e6279750310c9e9768" id="r_a76f4400d1f6375e6279750310c9e9768"><td class="memItemLeft" align="right" valign="top"><a id="a76f4400d1f6375e6279750310c9e9768" name="a76f4400d1f6375e6279750310c9e9768"></a>
&#160;</td><td class="memItemRight" valign="bottom"><b>CppStringT</b> (const CharT ch)</td></tr>
<tr class="memitem:a9a4f80ac4dcc031f97e8e4e278886132" id="r_a9a4f80ac4dcc031f97e8e4e278886132"><td class="memItemLeft" align="right" valign="top"><a id="a9a4f80ac4dcc031f97e8e4e278886132" name="a9a4f80ac4dcc031f97e8e4e278886132"></a>
&#160;</td><td class="memItemRight" valign="bottom"><b>CppStringT</b> (const <a class="el" href="classpcs_1_1_cpp_string_t.html">CppStringT</a> &amp;other)</td></tr>
<tr class="memitem:a5357df85972d8bc7612ffd75f184d7ff" id="r_a5357df85972d8bc7612ffd75f184d7ff"><td class="memItemLeft" align="right" valign="top"><a id="a5357df85972d8bc7612ffd75f184d7ff" name="a5357df85972d8bc7612ffd75f184d7ff"></a>
&#160;</td><td class="memItemRight" valign="bottom"><b>CppStringT</b> (const <a class="el" href="classpcs_1_1_cpp_string_t.html">CppStringT</a> &amp;other, const AllocatorT &amp;alloc)</td></tr>
<tr class="memitem:ab5bc3daf7844062fd2433cfbc44abd84" id="r_ab5bc3daf7844062fd2433cfbc44abd84"><td class="memItemLeft" align="right" valign="top"><a id="ab5bc3daf7844062fd2433cfbc44abd84" name="ab5bc3daf7844062fd2433cfbc44abd84"></a>
&#160;</td><td class="memItemRight" valign="bottom"><b>CppStringT</b> (const <a class="el" href="classpcs_1_1_cpp_string_t.html">CppStringT</a> &amp;other, size_type pos)</td></tr>
<tr class="memitem:a60709b3d9460d78229ff0b7a8b0bab0b" id="r_a60709b3d9460d78229ff0b7a8b0bab0b"><td class="memItemLeft" align="right" valign="top"><a id="a60709b3d9460d78229ff0b7a8b0bab0b" name="a60709b3d9460d78229ff0b7a8b0bab0b"></a>
&#160;</td><td class="memItemRight" valign="bottom"><b>CppStringT</b> (const <a class="el" href="classpcs_1_1_cpp_string_t.html">CppStringT</a> &amp;other, size_type pos, size_type <a class="el" href="#a7beda74b4d5092845a970d51d01fe4bf">count</a>) noexcept</td></tr>
<tr class="memitem:a63cbba245e11273c05aa598792532968" id="r_a63cbba245e11273c05aa598792532968"><td class="memItemLeft" align="right" valign="top"><a id="a63cbba245e11273c05aa598792532968" name="a63cbba245e11273c05aa598792532968"></a>
&#160;</td><td class="memItemRight" valign="bottom"><b>CppStringT</b> (const MyBaseClass &amp;other)</td></tr>
<tr class="memitem:a8f1f0b8ebdd0bd44d98aa66045d8c2af" id="r_a8f1f0b8ebdd0bd44d98aa66045d8c2af"><td class="memItemLeft" align="right" valign="top"><a id="a8f1f0b8ebdd0bd44d98aa66045d8c2af" name="a8f1f0b8ebdd0bd44d98aa66045d8c2af"></a>
&#160;</td><td class="memItemRight" valign="bottom"><b>CppStringT</b> (const MyBaseClass &amp;other, const AllocatorT &amp;alloc)</td></tr>
<tr class="memitem:a47ef2c70d9e156a2f259cecd2d0f1ac5" id="r_a47ef2c70d9e156a2f259cecd2d0f1ac5"><td class="memItemLeft" align="right" valign="top"><a id="a47ef2c70d9e156a2f259cecd2d0f1ac5" name="a47ef2c70d9e156a2f259cecd2d0f1ac5"></a>
&#160;</td><td class="memItemRight" valign="bottom"><b>CppStringT</b> (<a class="el" href="classpcs_1_1_cpp_string_t.html">CppStringT</a> &amp;&amp;other) noexcept</td></tr>
<tr class="memitem:a25614fc6b4b36bf9ac9fe8eb611cdfe9" id="r_a25614fc6b4b36bf9ac9fe8eb611cdfe9"><td class="memItemLeft" align="right" valign="top"><a id="a25614fc6b4b36bf9ac9fe8eb611cdfe9" name="a25614fc6b4b36bf9ac9fe8eb611cdfe9"></a>
&#160;</td><td class="memItemRight" valign="bottom"><b>CppStringT</b> (<a class="el" href="classpcs_1_1_cpp_string_t.html">CppStringT</a> &amp;&amp;other, const AllocatorT &amp;alloc) noexcept</td></tr>
<tr class="memitem:aa1cd7979de2fca6c80d47d2add26bff3" id="r_aa1cd7979de2fca6c80d47d2add26bff3"><td class="memTemplParams" colspan="2"><a id="aa1cd7979de2fca6c80d47d2add26bff3" name="aa1cd7979de2fca6c80d47d2add26bff3"></a>
template&lt;class InputIt&gt; </td></tr>
<tr class="memitem:aa1cd7979de2fca6c80d47d2add26bff3 template"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><b>CppStringT</b> (InputIt first, InputIt last)</td></tr>
<tr class="memitem:a604ea27c8780a7cd3fd72e18924b33d5" id="r_a604ea27c8780a7cd3fd72e18924b33d5"><td class="memItemLeft" align="right" valign="top"><a id="a604ea27c8780a7cd3fd72e18924b33d5" name="a604ea27c8780a7cd3fd72e18924b33d5"></a>
&#160;</td><td class="memItemRight" valign="bottom"><b>CppStringT</b> (MyBaseClass &amp;&amp;other)</td></tr>
<tr class="memitem:a6bb7e6f92fbd83db80ae0ed020791e25" id="r_a6bb7e6f92fbd83db80ae0ed020791e25"><td class="memItemLeft" align="right" valign="top"><a id="a6bb7e6f92fbd83db80ae0ed020791e25" name="a6bb7e6f92fbd83db80ae0ed020791e25"></a>
&#160;</td><td class="memItemRight" valign="bottom"><b>CppStringT</b> (MyBaseClass &amp;&amp;other, const AllocatorT &amp;alloc)</td></tr>
<tr class="memitem:a3f1f26894183b06681abc7d7353495a9" id="r_a3f1f26894183b06681abc7d7353495a9"><td class="memItemLeft" align="right" valign="top"><a id="a3f1f26894183b06681abc7d7353495a9" name="a3f1f26894183b06681abc7d7353495a9"></a>
&#160;</td><td class="memItemRight" valign="bottom"><b>CppStringT</b> (MyBaseClass::size_type <a class="el" href="#a7beda74b4d5092845a970d51d01fe4bf">count</a>, CharT ch)</td></tr>
<tr class="memitem:a46bdbd4db374ba694a107ce6b379fb7d" id="r_a46bdbd4db374ba694a107ce6b379fb7d"><td class="memItemLeft" align="right" valign="top"><a id="a46bdbd4db374ba694a107ce6b379fb7d" name="a46bdbd4db374ba694a107ce6b379fb7d"></a>
&#160;</td><td class="memItemRight" valign="bottom"><b>CppStringT</b> (std::initializer_list&lt; CharT &gt; ilist)</td></tr>
<tr class="memitem:aaa5553a8d93aa2f708e5b6d94741a7dd" id="r_aaa5553a8d93aa2f708e5b6d94741a7dd"><td class="memTemplParams" colspan="2"><a id="aaa5553a8d93aa2f708e5b6d94741a7dd" name="aaa5553a8d93aa2f708e5b6d94741a7dd"></a>
template&lt;class StringViewLike&gt; </td></tr>
<tr class="memitem:aaa5553a8d93aa2f708e5b6d94741a7dd template"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><b>CppStringT</b> (StringViewLike &amp;svl)</td></tr>
<tr class="memitem:ac3d06c5be9476150a5d07cc4a9d8e61d" id="r_ac3d06c5be9476150a5d07cc4a9d8e61d"><td class="memTemplParams" colspan="2"><a id="ac3d06c5be9476150a5d07cc4a9d8e61d" name="ac3d06c5be9476150a5d07cc4a9d8e61d"></a>
template&lt;class StringViewLike&gt; </td></tr>
<tr class="memitem:ac3d06c5be9476150a5d07cc4a9d8e61d template"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><b>CppStringT</b> (StringViewLike &amp;svl, size_type pos, size_type n)</td></tr>
<tr class="memitem:a3e9da0bfa54e84420e81668f6ce7f52c" id="r_a3e9da0bfa54e84420e81668f6ce7f52c"><td class="memItemLeft" align="right" valign="top">const bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a3e9da0bfa54e84420e81668f6ce7f52c">endswith</a> (const <a class="el" href="classpcs_1_1_cpp_string_t.html">CppStringT</a> &amp;suffix) const noexcept</td></tr>
<tr class="memdesc:a3e9da0bfa54e84420e81668f6ce7f52c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns true if the string ends with the specified suffix, otherwise returns false. Test runs on the whole string.  <br /></td></tr>
<tr class="memitem:a6b23210d7d5eb07c9f942d62cc76b05e" id="r_a6b23210d7d5eb07c9f942d62cc76b05e"><td class="memItemLeft" align="right" valign="top">const bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a6b23210d7d5eb07c9f942d62cc76b05e">endswith</a> (const <a class="el" href="classpcs_1_1_cpp_string_t.html">CppStringT</a> &amp;suffix, const size_type end) const noexcept</td></tr>
<tr class="memdesc:a6b23210d7d5eb07c9f942d62cc76b05e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns true if the string ends with the specified suffix, otherwise returns false. Test begins at start of string and stops at end position.  <br /></td></tr>
<tr class="memitem:a42f1e87d7f1903536ee79aa058d5c867" id="r_a42f1e87d7f1903536ee79aa058d5c867"><td class="memItemLeft" align="right" valign="top">const bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a42f1e87d7f1903536ee79aa058d5c867">endswith</a> (const <a class="el" href="classpcs_1_1_cpp_string_t.html">CppStringT</a> &amp;suffix, const size_type start, const size_type end) const noexcept</td></tr>
<tr class="memdesc:a42f1e87d7f1903536ee79aa058d5c867"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns true if the string ends with the specified suffix, otherwise returns false. Test begins at start position and stops at end position.  <br /></td></tr>
<tr class="memitem:a87b25fce2a05421efd718c599a784a09" id="r_a87b25fce2a05421efd718c599a784a09"><td class="memItemLeft" align="right" valign="top">const bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a87b25fce2a05421efd718c599a784a09">endswith</a> (const std::initializer_list&lt; <a class="el" href="classpcs_1_1_cpp_string_t.html">CppStringT</a> &gt; &amp;suffixes, const size_type start, const size_type end) const noexcept</td></tr>
<tr class="memdesc:a87b25fce2a05421efd718c599a784a09"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns true if the string ends with any of the specified suffixes, otherwise returns false. Test begins at start position and stops at end position.  <br /></td></tr>
<tr class="memitem:a619935926ef961883e9bbd92b2fc23bd" id="r_a619935926ef961883e9bbd92b2fc23bd"><td class="memItemLeft" align="right" valign="top">const bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a619935926ef961883e9bbd92b2fc23bd">endswith_n</a> (const <a class="el" href="classpcs_1_1_cpp_string_t.html">CppStringT</a> &amp;suffix, const size_type <a class="el" href="#a7beda74b4d5092845a970d51d01fe4bf">count</a>) const noexcept</td></tr>
<tr class="memdesc:a619935926ef961883e9bbd92b2fc23bd"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns true if the string ends with the specified suffix, otherwise returns false. Test begins at position 0 and stops after count positions.  <br /></td></tr>
<tr class="memitem:a7eca5636b598c6fc107452ddd04a2f17" id="r_a7eca5636b598c6fc107452ddd04a2f17"><td class="memItemLeft" align="right" valign="top">const bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a7eca5636b598c6fc107452ddd04a2f17">endswith_n</a> (const <a class="el" href="classpcs_1_1_cpp_string_t.html">CppStringT</a> &amp;suffix, const size_type start, const size_type <a class="el" href="#a7beda74b4d5092845a970d51d01fe4bf">count</a>) const noexcept</td></tr>
<tr class="memdesc:a7eca5636b598c6fc107452ddd04a2f17"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns true if the string ends with the specified suffix, otherwise returns false. Test begins at start position and stops after count positions.  <br /></td></tr>
<tr class="memitem:a4fd91047ab0126c823aa391a699e03bf" id="r_a4fd91047ab0126c823aa391a699e03bf"><td class="memItemLeft" align="right" valign="top">const bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a4fd91047ab0126c823aa391a699e03bf">endswith_n</a> (const std::initializer_list&lt; <a class="el" href="classpcs_1_1_cpp_string_t.html">CppStringT</a> &gt; &amp;suffixes, const size_type start, const size_type <a class="el" href="#a7beda74b4d5092845a970d51d01fe4bf">count</a>) const noexcept</td></tr>
<tr class="memdesc:a4fd91047ab0126c823aa391a699e03bf"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns true if the string ends with any of the specified suffixes, otherwise returns false. Test begins at start position and stops after count positions.  <br /></td></tr>
<tr class="memitem:a2cc04d5062162ff5f7b6111d6f1e78e8" id="r_a2cc04d5062162ff5f7b6111d6f1e78e8"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classpcs_1_1_cpp_string_t.html">CppStringT</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a2cc04d5062162ff5f7b6111d6f1e78e8">expand_tabs</a> (const size_type tabsize=8) const noexcept</td></tr>
<tr class="memdesc:a2cc04d5062162ff5f7b6111d6f1e78e8"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns a copy of the string where all tab characters are replaced by one or more spaces, depending on the current column and the given tab size.  <br /></td></tr>
<tr class="memitem:a24c4b7a0f713373cb3287d92289562ad" id="r_a24c4b7a0f713373cb3287d92289562ad"><td class="memItemLeft" align="right" valign="top">constexpr size_type&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a24c4b7a0f713373cb3287d92289562ad">find</a> (const <a class="el" href="classpcs_1_1_cpp_string_t.html">CppStringT</a> &amp;sub, const size_type start=0, const size_type end=-1) const noexcept</td></tr>
<tr class="memdesc:a24c4b7a0f713373cb3287d92289562ad"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the lowest index in the string where substring sub is found within the slice str[start:end], or -1 (i.e. 'npos') if sub is not found.  <br /></td></tr>
<tr class="memitem:a6b0bc87b284120d0d3bfc685984997c0" id="r_a6b0bc87b284120d0d3bfc685984997c0"><td class="memItemLeft" align="right" valign="top">constexpr size_type&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a6b0bc87b284120d0d3bfc685984997c0">find_n</a> (const <a class="el" href="classpcs_1_1_cpp_string_t.html">CppStringT</a> &amp;sub, const size_type <a class="el" href="#a7beda74b4d5092845a970d51d01fe4bf">count</a>) const noexcept</td></tr>
<tr class="memdesc:a6b0bc87b284120d0d3bfc685984997c0"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the lowest index in the string where substring sub is found within the slice str[0:count-1], or -1 (i.e. 'npos') if sub is not found.  <br /></td></tr>
<tr class="memitem:ac4c9351bb52eb9a62fa7fb2e2d5f054d" id="r_ac4c9351bb52eb9a62fa7fb2e2d5f054d"><td class="memItemLeft" align="right" valign="top">constexpr size_type&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ac4c9351bb52eb9a62fa7fb2e2d5f054d">find_n</a> (const <a class="el" href="classpcs_1_1_cpp_string_t.html">CppStringT</a> &amp;sub, const size_type start, const size_type <a class="el" href="#a7beda74b4d5092845a970d51d01fe4bf">count</a>) const noexcept</td></tr>
<tr class="memdesc:ac4c9351bb52eb9a62fa7fb2e2d5f054d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the lowest index in the string where substring sub is found within the slice str[start:start+count-1], or -1 (i.e. 'npos') if sub is not found.  <br /></td></tr>
<tr class="memitem:a1a89389b38fd6af3ea8db3489dd82f70" id="r_a1a89389b38fd6af3ea8db3489dd82f70"><td class="memTemplParams" colspan="2">template&lt;class... ArgsT&gt; </td></tr>
<tr class="memitem:a1a89389b38fd6af3ea8db3489dd82f70 template"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classpcs_1_1_cpp_string_t.html">CppStringT</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a1a89389b38fd6af3ea8db3489dd82f70">format</a> (const std::basic_format_string&lt; char, std::type_identity_t&lt; ArgsT &gt;... &gt; frmt, ArgsT &amp;&amp;... args)</td></tr>
<tr class="memitem:a5caecc371bf390272283ceb7a15c6c1d" id="r_a5caecc371bf390272283ceb7a15c6c1d"><td class="memTemplParams" colspan="2">template&lt;typename T, class... ArgsT&gt; </td></tr>
<tr class="memitem:a5caecc371bf390272283ceb7a15c6c1d template"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classpcs_1_1_cpp_string_t.html">CppStringT</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a5caecc371bf390272283ceb7a15c6c1d">format</a> (const std::basic_format_string&lt; T, std::type_identity_t&lt; ArgsT &gt;... &gt; frmt, ArgsT &amp;&amp;... args)</td></tr>
<tr class="memdesc:a5caecc371bf390272283ceb7a15c6c1d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Formats this string according to c++20 std::format() specification. Returns this string.  <br /></td></tr>
<tr class="memitem:a944e066f3a863c354a5613a6eda17374" id="r_a944e066f3a863c354a5613a6eda17374"><td class="memTemplParams" colspan="2">template&lt;class... ArgsT&gt; </td></tr>
<tr class="memitem:a944e066f3a863c354a5613a6eda17374 template"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classpcs_1_1_cpp_string_t.html">CppStringT</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a944e066f3a863c354a5613a6eda17374">format</a> (const std::basic_format_string&lt; wchar_t, std::type_identity_t&lt; ArgsT &gt;... &gt; frmt, ArgsT &amp;&amp;... args)</td></tr>
<tr class="memitem:a277a2b8a3b93951ccb94b6bf39daa582" id="r_a277a2b8a3b93951ccb94b6bf39daa582"><td class="memItemLeft" align="right" valign="top">constexpr size_type&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a277a2b8a3b93951ccb94b6bf39daa582">index</a> (const <a class="el" href="classpcs_1_1_cpp_string_t.html">CppStringT</a> &amp;sub, const size_type start=0, const size_type end=-1) const</td></tr>
<tr class="memdesc:a277a2b8a3b93951ccb94b6bf39daa582"><td class="mdescLeft">&#160;</td><td class="mdescRight">Like find(const CppStringT&amp;), but raises <a class="el" href="classpcs_1_1_cpp_string_t_1_1_not_found_exception.html">NotFoundException</a> when the substring sub is not found.  <br /></td></tr>
<tr class="memitem:a19a51054b824add817f30c5ff03effe7" id="r_a19a51054b824add817f30c5ff03effe7"><td class="memItemLeft" align="right" valign="top">constexpr size_type&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a19a51054b824add817f30c5ff03effe7">index_n</a> (const <a class="el" href="classpcs_1_1_cpp_string_t.html">CppStringT</a> &amp;sub, const size_type <a class="el" href="#a7beda74b4d5092845a970d51d01fe4bf">count</a>) const</td></tr>
<tr class="memdesc:a19a51054b824add817f30c5ff03effe7"><td class="mdescLeft">&#160;</td><td class="mdescRight">Like find_n(sub, count), but raises <a class="el" href="classpcs_1_1_cpp_string_t_1_1_not_found_exception.html">NotFoundException</a> when the substring is not found.  <br /></td></tr>
<tr class="memitem:aee94d4b52483021051b168e776b18569" id="r_aee94d4b52483021051b168e776b18569"><td class="memItemLeft" align="right" valign="top">constexpr size_type&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#aee94d4b52483021051b168e776b18569">index_n</a> (const <a class="el" href="classpcs_1_1_cpp_string_t.html">CppStringT</a> &amp;sub, const size_type start, const size_type <a class="el" href="#a7beda74b4d5092845a970d51d01fe4bf">count</a>) const</td></tr>
<tr class="memdesc:aee94d4b52483021051b168e776b18569"><td class="mdescLeft">&#160;</td><td class="mdescRight">Like find_n(sub, start, count), but raises <a class="el" href="classpcs_1_1_cpp_string_t_1_1_not_found_exception.html">NotFoundException</a> when the substring is not found.  <br /></td></tr>
<tr class="memitem:a7565e4f2958e485ee2b0815be1faa0fa" id="r_a7565e4f2958e485ee2b0815be1faa0fa"><td class="memItemLeft" align="right" valign="top">const bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a7565e4f2958e485ee2b0815be1faa0fa">is_words_sep</a> () const noexcept</td></tr>
<tr class="memdesc:a7565e4f2958e485ee2b0815be1faa0fa"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns true if there are only whitespace and punctuation characters in the string and there is at least one character, or false otherwise.  <br /></td></tr>
<tr class="memitem:a8fdf96ffee524d5b795c4aad26ece6ae" id="r_a8fdf96ffee524d5b795c4aad26ece6ae"><td class="memItemLeft" align="right" valign="top">const bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a8fdf96ffee524d5b795c4aad26ece6ae">isalnum</a> () const noexcept</td></tr>
<tr class="memdesc:a8fdf96ffee524d5b795c4aad26ece6ae"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns true if all characters in the string are alphanumeric and there is at least one character, or false otherwise.  <br /></td></tr>
<tr class="memitem:a447b7c58b4be1cdcba3aedf189acbce7" id="r_a447b7c58b4be1cdcba3aedf189acbce7"><td class="memItemLeft" align="right" valign="top">const bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a447b7c58b4be1cdcba3aedf189acbce7">isalpha</a> () const noexcept</td></tr>
<tr class="memdesc:a447b7c58b4be1cdcba3aedf189acbce7"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns true if all characters in the string are alphabetic and there is at least one character, or false otherwise.  <br /></td></tr>
<tr class="memitem:a710631f31d4c63c2117e8f4804fad3f2" id="r_a710631f31d4c63c2117e8f4804fad3f2"><td class="memItemLeft" align="right" valign="top">const bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a710631f31d4c63c2117e8f4804fad3f2">isascii</a> () const noexcept</td></tr>
<tr class="memdesc:a710631f31d4c63c2117e8f4804fad3f2"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns true if the string is empty or all characters in the string are ASCII, or false otherwise.  <br /></td></tr>
<tr class="memitem:a0b9d8a55419274e7cfd9badb4df704e3" id="r_a0b9d8a55419274e7cfd9badb4df704e3"><td class="memItemLeft" align="right" valign="top">const bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a0b9d8a55419274e7cfd9badb4df704e3">isdecimal</a> () const noexcept</td></tr>
<tr class="memdesc:a0b9d8a55419274e7cfd9badb4df704e3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns true if all characters in the string are decimal characters and there is at least one character, or false otherwise.  <br /></td></tr>
<tr class="memitem:a21316d00180377a3f48910a6c4c43b9c" id="r_a21316d00180377a3f48910a6c4c43b9c"><td class="memItemLeft" align="right" valign="top">const bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a21316d00180377a3f48910a6c4c43b9c">isdigit</a> () const noexcept</td></tr>
<tr class="memdesc:a21316d00180377a3f48910a6c4c43b9c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns true if all characters in the string are digits and there is at least one character, or false otherwise.  <br /></td></tr>
<tr class="memitem:a91f72d425dbb4c53a066338d30683246" id="r_a91f72d425dbb4c53a066338d30683246"><td class="memItemLeft" align="right" valign="top">const bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a91f72d425dbb4c53a066338d30683246">isidentifier</a> () const noexcept</td></tr>
<tr class="memdesc:a91f72d425dbb4c53a066338d30683246"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns true if the string is not empty and is a valid identifier according to the language definition, or false otherwise.  <br /></td></tr>
<tr class="memitem:ae4ff448bb92e6499c0a76f7d8e11126c" id="r_ae4ff448bb92e6499c0a76f7d8e11126c"><td class="memItemLeft" align="right" valign="top">const bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ae4ff448bb92e6499c0a76f7d8e11126c">islower</a> () const noexcept</td></tr>
<tr class="memdesc:ae4ff448bb92e6499c0a76f7d8e11126c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns true if all cased characters in the string are lowercase and there is at least one cased character, or false otherwise.  <br /></td></tr>
<tr class="memitem:a578176ed20fd8da965afbcae1d99dd59" id="r_a578176ed20fd8da965afbcae1d99dd59"><td class="memItemLeft" align="right" valign="top">const bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a578176ed20fd8da965afbcae1d99dd59">isnumeric</a> () const noexcept</td></tr>
<tr class="memdesc:a578176ed20fd8da965afbcae1d99dd59"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns true if all characters in the string are numeric characters, and there is at least one character, or false otherwise.  <br /></td></tr>
<tr class="memitem:a6257a1832da550d4be32e9f272e51265" id="r_a6257a1832da550d4be32e9f272e51265"><td class="memItemLeft" align="right" valign="top">const bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a6257a1832da550d4be32e9f272e51265">isprintable</a> () const noexcept</td></tr>
<tr class="memdesc:a6257a1832da550d4be32e9f272e51265"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns true if all characters in the string are printable or if the string is empty, or false otherwise.  <br /></td></tr>
<tr class="memitem:a2842f3a067fdc674709bed048d64e12d" id="r_a2842f3a067fdc674709bed048d64e12d"><td class="memItemLeft" align="right" valign="top">const bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a2842f3a067fdc674709bed048d64e12d">ispunctuation</a> () const noexcept</td></tr>
<tr class="memdesc:a2842f3a067fdc674709bed048d64e12d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns true if the string contains only one character and if this character belongs to the ASCII punctuation set.  <br /></td></tr>
<tr class="memitem:a959a8f56bb536f2474ffc649a7ad3290" id="r_a959a8f56bb536f2474ffc649a7ad3290"><td class="memItemLeft" align="right" valign="top">const bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a959a8f56bb536f2474ffc649a7ad3290">isspace</a> () const noexcept</td></tr>
<tr class="memdesc:a959a8f56bb536f2474ffc649a7ad3290"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns true if there are only whitespace characters in the string and there is at least one character, or false otherwise.  <br /></td></tr>
<tr class="memitem:ad72611f339c2b9027a72fa26f25748c3" id="r_ad72611f339c2b9027a72fa26f25748c3"><td class="memItemLeft" align="right" valign="top">const bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ad72611f339c2b9027a72fa26f25748c3">istitle</a> () const noexcept</td></tr>
<tr class="memdesc:ad72611f339c2b9027a72fa26f25748c3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns true if the string is a titlecased string and there is at least one character, or false otherwise.  <br /></td></tr>
<tr class="memitem:af2784cbe9655bb8e23fe90375d79e69c" id="r_af2784cbe9655bb8e23fe90375d79e69c"><td class="memItemLeft" align="right" valign="top">const bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#af2784cbe9655bb8e23fe90375d79e69c">isupper</a> () const noexcept</td></tr>
<tr class="memdesc:af2784cbe9655bb8e23fe90375d79e69c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns true if all cased characters in the string are uppercase and there is at least one cased character, or false otherwise.  <br /></td></tr>
<tr class="memitem:aa3523b858357399995e4fb9ec796c96c" id="r_aa3523b858357399995e4fb9ec796c96c"><td class="memItemLeft" align="right" valign="top">const <a class="el" href="classpcs_1_1_cpp_string_t.html">CppStringT</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#aa3523b858357399995e4fb9ec796c96c">join</a> () const noexcept</td></tr>
<tr class="memdesc:aa3523b858357399995e4fb9ec796c96c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Empty parameters list signature. Returns a copy of current string.  <br /></td></tr>
<tr class="memitem:a545d669bb9296b5695b01ac8680bf3f4" id="r_a545d669bb9296b5695b01ac8680bf3f4"><td class="memTemplParams" colspan="2">template&lt;class... NextCppStringsT&gt; <br />
requires (sizeof...(others) &gt; 0)</td></tr>
<tr class="memitem:a545d669bb9296b5695b01ac8680bf3f4 template"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classpcs_1_1_cpp_string_t.html">CppStringT</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a545d669bb9296b5695b01ac8680bf3f4">join</a> (const <a class="el" href="classpcs_1_1_cpp_string_t.html">CppStringT</a> &amp;first, const NextCppStringsT &amp;... others) const noexcept</td></tr>
<tr class="memdesc:a545d669bb9296b5695b01ac8680bf3f4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns a string which is the concatenation of the strings in the parameters list.  <br /></td></tr>
<tr class="memitem:a30860a043574996d85c80e49ef618594" id="r_a30860a043574996d85c80e49ef618594"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classpcs_1_1_cpp_string_t.html">CppStringT</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a30860a043574996d85c80e49ef618594">join</a> (const <a class="el" href="classpcs_1_1_cpp_string_t.html">CppStringT</a> &amp;s) const noexcept</td></tr>
<tr class="memdesc:a30860a043574996d85c80e49ef618594"><td class="mdescLeft">&#160;</td><td class="mdescRight">Single parameter signature. Returns a copy of this parameter.  <br /></td></tr>
<tr class="memitem:ac1b427d4cc4c2aed8252b3526b63f1b1" id="r_ac1b427d4cc4c2aed8252b3526b63f1b1"><td class="memTemplParams" colspan="2">template&lt;const std::size_t N&gt; </td></tr>
<tr class="memitem:ac1b427d4cc4c2aed8252b3526b63f1b1 template"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classpcs_1_1_cpp_string_t.html">CppStringT</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ac1b427d4cc4c2aed8252b3526b63f1b1">join</a> (const std::array&lt; <a class="el" href="classpcs_1_1_cpp_string_t.html">CppStringT</a>, N &gt; &amp;strs) const noexcept</td></tr>
<tr class="memdesc:ac1b427d4cc4c2aed8252b3526b63f1b1"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns a string which is the concatenation of the strings in the array parameter.  <br /></td></tr>
<tr class="memitem:a9eed3f6c5e09f98f3d5916cc5b3a4311" id="r_a9eed3f6c5e09f98f3d5916cc5b3a4311"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classpcs_1_1_cpp_string_t.html">CppStringT</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a9eed3f6c5e09f98f3d5916cc5b3a4311">join</a> (const std::vector&lt; <a class="el" href="classpcs_1_1_cpp_string_t.html">CppStringT</a> &gt; &amp;strs) const noexcept</td></tr>
<tr class="memdesc:a9eed3f6c5e09f98f3d5916cc5b3a4311"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns a string which is the concatenation of the strings in the vector parameter.  <br /></td></tr>
<tr class="memitem:aed96c44c384cab45342122cd7e2f02eb" id="r_aed96c44c384cab45342122cd7e2f02eb"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classpcs_1_1_cpp_string_t.html">CppStringT</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#aed96c44c384cab45342122cd7e2f02eb">ljust</a> (const size_type width, const value_type fillch=value_type(' ')) const noexcept</td></tr>
<tr class="memdesc:aed96c44c384cab45342122cd7e2f02eb"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the string left justified in a string of length width.  <br /></td></tr>
<tr class="memitem:ad5c765eaa85cb4a3e7a914d55a6a5175" id="r_ad5c765eaa85cb4a3e7a914d55a6a5175"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classpcs_1_1_cpp_string_t.html">CppStringT</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ad5c765eaa85cb4a3e7a914d55a6a5175">lower</a> () noexcept</td></tr>
<tr class="memdesc:ad5c765eaa85cb4a3e7a914d55a6a5175"><td class="mdescLeft">&#160;</td><td class="mdescRight">In-place replaces all characters of the string with their lowercase conversion. Returns a reference to string.  <br /></td></tr>
<tr class="memitem:ac1ad3018d38f291e6debad8d2de92be1" id="r_ac1ad3018d38f291e6debad8d2de92be1"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classpcs_1_1_cpp_string_t.html">CppStringT</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ac1ad3018d38f291e6debad8d2de92be1">lstrip</a> () const noexcept</td></tr>
<tr class="memdesc:ac1ad3018d38f291e6debad8d2de92be1"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns a copy of the string with leading whitespaces removed.  <br /></td></tr>
<tr class="memitem:aee6e48d5b478d5bab239f54523d23c15" id="r_aee6e48d5b478d5bab239f54523d23c15"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classpcs_1_1_cpp_string_t.html">CppStringT</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#aee6e48d5b478d5bab239f54523d23c15">lstrip</a> (const <a class="el" href="classpcs_1_1_cpp_string_t.html">CppStringT</a> &amp;removedchars) const noexcept</td></tr>
<tr class="memdesc:aee6e48d5b478d5bab239f54523d23c15"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns a copy of the string with leading characters removed.  <br /></td></tr>
<tr class="memitem:a0daec57ccab4601f46e9d1c258407765" id="r_a0daec57ccab4601f46e9d1c258407765"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classpcs_1_1_cpp_string_t.html">CppStringT</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a0daec57ccab4601f46e9d1c258407765">operator()</a> (const long long start, const long long stop, const long long step=1) const noexcept</td></tr>
<tr class="memdesc:a0daec57ccab4601f46e9d1c258407765"><td class="mdescLeft">&#160;</td><td class="mdescRight">Generates a new string according to the specified slicing values.  <br /></td></tr>
<tr class="memitem:a1fa8862a5f306553d6f0dae7e76fce83" id="r_a1fa8862a5f306553d6f0dae7e76fce83"><td class="memTemplParams" colspan="2">template&lt;typename IntT&gt; <br />
requires std::is_signed_v&lt;IntT&gt;</td></tr>
<tr class="memitem:a1fa8862a5f306553d6f0dae7e76fce83 template"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classpcs_1_1_cpp_string_t.html">CppStringT</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a1fa8862a5f306553d6f0dae7e76fce83">operator()</a> (<a class="el" href="classpcs_1_1_slice.html">Slice</a>&lt; IntT &gt; slice) const noexcept</td></tr>
<tr class="memdesc:a1fa8862a5f306553d6f0dae7e76fce83"><td class="mdescLeft">&#160;</td><td class="mdescRight">Generates a new string according to the specified slice.  <br /></td></tr>
<tr class="memitem:a0995f5b5a01af3f4a749949e23d0d780" id="r_a0995f5b5a01af3f4a749949e23d0d780"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classpcs_1_1_cpp_string_t.html">CppStringT</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a0995f5b5a01af3f4a749949e23d0d780">operator*</a> (std::int64_t <a class="el" href="#a7beda74b4d5092845a970d51d01fe4bf">count</a>) const noexcept</td></tr>
<tr class="memdesc:a0995f5b5a01af3f4a749949e23d0d780"><td class="mdescLeft">&#160;</td><td class="mdescRight">Generates a new string with count times the content of this string.  <br /></td></tr>
<tr class="memitem:a30e26a3082ad50d01c7d0d98cb9e9c37" id="r_a30e26a3082ad50d01c7d0d98cb9e9c37"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classpcs_1_1_cpp_string_t.html">CppStringT</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a30e26a3082ad50d01c7d0d98cb9e9c37">operator=</a> (const <a class="el" href="classpcs_1_1_cpp_string_t.html">CppStringT</a> &amp;) noexcept=default</td></tr>
<tr class="memdesc:a30e26a3082ad50d01c7d0d98cb9e9c37"><td class="mdescLeft">&#160;</td><td class="mdescRight">Default copy assignment.  <br /></td></tr>
<tr class="memitem:a810a3a27ee7396f9c472648978327a76" id="r_a810a3a27ee7396f9c472648978327a76"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classpcs_1_1_cpp_string_t.html">CppStringT</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a810a3a27ee7396f9c472648978327a76">operator=</a> (<a class="el" href="classpcs_1_1_cpp_string_t.html">CppStringT</a> &amp;&amp;) noexcept=default</td></tr>
<tr class="memdesc:a810a3a27ee7396f9c472648978327a76"><td class="mdescLeft">&#160;</td><td class="mdescRight">Default move assignment.  <br /></td></tr>
<tr class="memitem:ac5f88b0fc1f33cda23c30cb1f3bc560f" id="r_ac5f88b0fc1f33cda23c30cb1f3bc560f"><td class="memItemLeft" align="right" valign="top">std::vector&lt; <a class="el" href="classpcs_1_1_cpp_string_t.html">CppStringT</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ac5f88b0fc1f33cda23c30cb1f3bc560f">partition</a> (const <a class="el" href="classpcs_1_1_cpp_string_t.html">CppStringT</a> &amp;sep) const noexcept</td></tr>
<tr class="memdesc:ac5f88b0fc1f33cda23c30cb1f3bc560f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Splits the string at the first occurrence of sep, and returns a 3-items vector containing the part before the separator, the separator itself, and the part after the separator.  <br /></td></tr>
<tr class="memitem:a058704b7f4538ec9e1798c5348d37c7a" id="r_a058704b7f4538ec9e1798c5348d37c7a"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classpcs_1_1_cpp_string_t.html">CppStringT</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a058704b7f4538ec9e1798c5348d37c7a">removeprefix</a> (const <a class="el" href="classpcs_1_1_cpp_string_t.html">CppStringT</a> &amp;prefix) const noexcept</td></tr>
<tr class="memdesc:a058704b7f4538ec9e1798c5348d37c7a"><td class="mdescLeft">&#160;</td><td class="mdescRight">If the string starts with the prefix string, returns a new string with the prefix removed. Otherwise, returns a copy of the original string.  <br /></td></tr>
<tr class="memitem:ad6a8dc124ab8b7cab1cb328240763ed0" id="r_ad6a8dc124ab8b7cab1cb328240763ed0"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classpcs_1_1_cpp_string_t.html">CppStringT</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ad6a8dc124ab8b7cab1cb328240763ed0">removesuffix</a> (const <a class="el" href="classpcs_1_1_cpp_string_t.html">CppStringT</a> &amp;suffix) const noexcept</td></tr>
<tr class="memdesc:ad6a8dc124ab8b7cab1cb328240763ed0"><td class="mdescLeft">&#160;</td><td class="mdescRight">If the string ends with the suffix string, returns a new string with the suffix removed. Otherwise, returns a copy of the original string.  <br /></td></tr>
<tr class="memitem:ad4f39683db649aa8a65907268c499f02" id="r_ad4f39683db649aa8a65907268c499f02"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classpcs_1_1_cpp_string_t.html">CppStringT</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ad4f39683db649aa8a65907268c499f02">replace</a> (const <a class="el" href="classpcs_1_1_cpp_string_t.html">CppStringT</a> &amp;old, const <a class="el" href="classpcs_1_1_cpp_string_t.html">CppStringT</a> &amp;new_, size_type <a class="el" href="#a7beda74b4d5092845a970d51d01fe4bf">count</a>=-1) const noexcept</td></tr>
<tr class="memdesc:ad4f39683db649aa8a65907268c499f02"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns a copy of the string with first count occurrences of substring 'old' replaced by 'new_'.  <br /></td></tr>
<tr class="memitem:ac00bb6f7d74bfdde0d4cc247e78ab20e" id="r_ac00bb6f7d74bfdde0d4cc247e78ab20e"><td class="memItemLeft" align="right" valign="top">constexpr size_type&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ac00bb6f7d74bfdde0d4cc247e78ab20e">rfind</a> (const <a class="el" href="classpcs_1_1_cpp_string_t.html">CppStringT</a> &amp;sub) const noexcept</td></tr>
<tr class="memdesc:ac00bb6f7d74bfdde0d4cc247e78ab20e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the highest index in the string where C-substring sub is found in the whole string, or -1 (i.e. 'npos') if sub is not found.  <br /></td></tr>
<tr class="memitem:a9f43f20029596abc1362d1242e68e5db" id="r_a9f43f20029596abc1362d1242e68e5db"><td class="memItemLeft" align="right" valign="top">constexpr size_type&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a9f43f20029596abc1362d1242e68e5db">rfind</a> (const <a class="el" href="classpcs_1_1_cpp_string_t.html">CppStringT</a> &amp;sub, const size_type start) const noexcept</td></tr>
<tr class="memdesc:a9f43f20029596abc1362d1242e68e5db"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the highest index in the string where substring sub is found starting at start position in string, or -1 (i.e. 'npos') if sub is not found.  <br /></td></tr>
<tr class="memitem:af363308ba741b267641e1aa35669d603" id="r_af363308ba741b267641e1aa35669d603"><td class="memItemLeft" align="right" valign="top">constexpr size_type&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#af363308ba741b267641e1aa35669d603">rfind</a> (const <a class="el" href="classpcs_1_1_cpp_string_t.html">CppStringT</a> &amp;sub, const size_type start, const size_type end) const noexcept</td></tr>
<tr class="memdesc:af363308ba741b267641e1aa35669d603"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the highest index in the string where substring sub is found within the slice str[start:end], or -1 (i.e. 'npos') if sub is not found.  <br /></td></tr>
<tr class="memitem:a790f663f51dfe6e9e15d4f5f025bf107" id="r_a790f663f51dfe6e9e15d4f5f025bf107"><td class="memItemLeft" align="right" valign="top">constexpr size_type&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a790f663f51dfe6e9e15d4f5f025bf107">rfind_n</a> (const <a class="el" href="classpcs_1_1_cpp_string_t.html">CppStringT</a> &amp;sub, const size_type <a class="el" href="#a7beda74b4d5092845a970d51d01fe4bf">count</a>) const noexcept</td></tr>
<tr class="memdesc:a790f663f51dfe6e9e15d4f5f025bf107"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the highest index in the string where substring sub is found within the slice str[0:count-1], or -1 (i.e. 'npos') if sub is not found.  <br /></td></tr>
<tr class="memitem:a519a292eb3f0790d54a59a201f2d6410" id="r_a519a292eb3f0790d54a59a201f2d6410"><td class="memItemLeft" align="right" valign="top">constexpr size_type&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a519a292eb3f0790d54a59a201f2d6410">rfind_n</a> (const <a class="el" href="classpcs_1_1_cpp_string_t.html">CppStringT</a> &amp;sub, const size_type start, const size_type <a class="el" href="#a7beda74b4d5092845a970d51d01fe4bf">count</a>) const noexcept</td></tr>
<tr class="memdesc:a519a292eb3f0790d54a59a201f2d6410"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the highest index in the string where substring sub is found within the slice str[start:start+count-1], or -1 (i.e. 'npos') if sub is not found.  <br /></td></tr>
<tr class="memitem:a546105cc9a8a9d493979c30607092cf1" id="r_a546105cc9a8a9d493979c30607092cf1"><td class="memItemLeft" align="right" valign="top">constexpr size_type&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a546105cc9a8a9d493979c30607092cf1">rindex</a> (const <a class="el" href="classpcs_1_1_cpp_string_t.html">CppStringT</a> &amp;sub) const</td></tr>
<tr class="memdesc:a546105cc9a8a9d493979c30607092cf1"><td class="mdescLeft">&#160;</td><td class="mdescRight">Like rfind(sub), but raises <a class="el" href="classpcs_1_1_cpp_string_t_1_1_not_found_exception.html">NotFoundException</a> when the substring is not found.  <br /></td></tr>
<tr class="memitem:a2baca0ddff848de56a7b867f68d3efab" id="r_a2baca0ddff848de56a7b867f68d3efab"><td class="memItemLeft" align="right" valign="top">constexpr size_type&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a2baca0ddff848de56a7b867f68d3efab">rindex</a> (const <a class="el" href="classpcs_1_1_cpp_string_t.html">CppStringT</a> &amp;sub, const size_type start) const</td></tr>
<tr class="memdesc:a2baca0ddff848de56a7b867f68d3efab"><td class="mdescLeft">&#160;</td><td class="mdescRight">Like rfind(sub, start), but raises <a class="el" href="classpcs_1_1_cpp_string_t_1_1_not_found_exception.html">NotFoundException</a> when the substring is not found.  <br /></td></tr>
<tr class="memitem:a6693ec49258c6ac80a7875b3ebf3c916" id="r_a6693ec49258c6ac80a7875b3ebf3c916"><td class="memItemLeft" align="right" valign="top">constexpr size_type&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a6693ec49258c6ac80a7875b3ebf3c916">rindex</a> (const <a class="el" href="classpcs_1_1_cpp_string_t.html">CppStringT</a> &amp;sub, const size_type start, const size_type end) const</td></tr>
<tr class="memdesc:a6693ec49258c6ac80a7875b3ebf3c916"><td class="mdescLeft">&#160;</td><td class="mdescRight">Like rfind(sub, start, end), but raises <a class="el" href="classpcs_1_1_cpp_string_t_1_1_not_found_exception.html">NotFoundException</a> when the substring is not found.  <br /></td></tr>
<tr class="memitem:ac3079cbecbdf4151e66f602f39ece836" id="r_ac3079cbecbdf4151e66f602f39ece836"><td class="memItemLeft" align="right" valign="top">constexpr size_type&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ac3079cbecbdf4151e66f602f39ece836">rindex_n</a> (const <a class="el" href="classpcs_1_1_cpp_string_t.html">CppStringT</a> &amp;sub, const size_type <a class="el" href="#a7beda74b4d5092845a970d51d01fe4bf">count</a>) const</td></tr>
<tr class="memdesc:ac3079cbecbdf4151e66f602f39ece836"><td class="mdescLeft">&#160;</td><td class="mdescRight">Like rfind_n(sub, count), but raises <a class="el" href="classpcs_1_1_cpp_string_t_1_1_not_found_exception.html">NotFoundException</a> when the substring is not found.  <br /></td></tr>
<tr class="memitem:afc08a4e91b93710838c8f0d6234e057e" id="r_afc08a4e91b93710838c8f0d6234e057e"><td class="memItemLeft" align="right" valign="top">constexpr size_type&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#afc08a4e91b93710838c8f0d6234e057e">rindex_n</a> (const <a class="el" href="classpcs_1_1_cpp_string_t.html">CppStringT</a> &amp;sub, const size_type start, const size_type <a class="el" href="#a7beda74b4d5092845a970d51d01fe4bf">count</a>) const</td></tr>
<tr class="memdesc:afc08a4e91b93710838c8f0d6234e057e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Like rfind_n(sub, start, count), but raises <a class="el" href="classpcs_1_1_cpp_string_t_1_1_not_found_exception.html">NotFoundException</a> when the substring is not found.  <br /></td></tr>
<tr class="memitem:a61fd4215938ec9f0fce1f885d6bb4a2b" id="r_a61fd4215938ec9f0fce1f885d6bb4a2b"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classpcs_1_1_cpp_string_t.html">CppStringT</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a61fd4215938ec9f0fce1f885d6bb4a2b">rjust</a> (const size_type width, const value_type fillch=value_type(' ')) const noexcept</td></tr>
<tr class="memdesc:a61fd4215938ec9f0fce1f885d6bb4a2b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the string right justified in a string of length width.  <br /></td></tr>
<tr class="memitem:a61674ee4e97038d82ea7ecc30b1761f6" id="r_a61674ee4e97038d82ea7ecc30b1761f6"><td class="memItemLeft" align="right" valign="top">std::vector&lt; <a class="el" href="classpcs_1_1_cpp_string_t.html">CppStringT</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a61674ee4e97038d82ea7ecc30b1761f6">rpartition</a> (const <a class="el" href="classpcs_1_1_cpp_string_t.html">CppStringT</a> &amp;sep) const noexcept</td></tr>
<tr class="memdesc:a61674ee4e97038d82ea7ecc30b1761f6"><td class="mdescLeft">&#160;</td><td class="mdescRight">Splits the string at the last occurrence of sep, and returns a 3-items vector containing the part before the separator, the separator itself, and the part after the separator.  <br /></td></tr>
<tr class="memitem:a8111cd357773d304fbb496571d7ee6be" id="r_a8111cd357773d304fbb496571d7ee6be"><td class="memItemLeft" align="right" valign="top">std::vector&lt; <a class="el" href="classpcs_1_1_cpp_string_t.html">CppStringT</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a8111cd357773d304fbb496571d7ee6be">rsplit</a> () noexcept</td></tr>
<tr class="memdesc:a8111cd357773d304fbb496571d7ee6be"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns a vector of the words in the whole string, as seperated with whitespace strings.  <br /></td></tr>
<tr class="memitem:a0419f46de6fa532372f3b97b4927ebab" id="r_a0419f46de6fa532372f3b97b4927ebab"><td class="memItemLeft" align="right" valign="top">std::vector&lt; <a class="el" href="classpcs_1_1_cpp_string_t.html">CppStringT</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a0419f46de6fa532372f3b97b4927ebab">rsplit</a> (const <a class="el" href="classpcs_1_1_cpp_string_t.html">CppStringT</a> &amp;sep) noexcept</td></tr>
<tr class="memdesc:a0419f46de6fa532372f3b97b4927ebab"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns a vector of the words in the whole string, using sep as the delimiter string.  <br /></td></tr>
<tr class="memitem:ab0ace502f0b3026fefd2942a1e8a0456" id="r_ab0ace502f0b3026fefd2942a1e8a0456"><td class="memItemLeft" align="right" valign="top">std::vector&lt; <a class="el" href="classpcs_1_1_cpp_string_t.html">CppStringT</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ab0ace502f0b3026fefd2942a1e8a0456">rsplit</a> (const <a class="el" href="classpcs_1_1_cpp_string_t.html">CppStringT</a> &amp;sep, const size_type maxsplit) noexcept</td></tr>
<tr class="memdesc:ab0ace502f0b3026fefd2942a1e8a0456"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns a vector of the words in the string, using sep as the delimiter string. At most maxsplit splits are done, the rightmost ones.  <br /></td></tr>
<tr class="memitem:a3aa66706e268bd570a0084d70dff5cde" id="r_a3aa66706e268bd570a0084d70dff5cde"><td class="memItemLeft" align="right" valign="top">std::vector&lt; <a class="el" href="classpcs_1_1_cpp_string_t.html">CppStringT</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a3aa66706e268bd570a0084d70dff5cde">rsplit</a> (const size_type maxsplit) noexcept</td></tr>
<tr class="memdesc:a3aa66706e268bd570a0084d70dff5cde"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns a vector of the words in the string, as seperated with whitespace strings. At most maxsplit splits are done, the rightmost ones.  <br /></td></tr>
<tr class="memitem:a86f8c78b2eeb3541fb6b56b4f4ac237b" id="r_a86f8c78b2eeb3541fb6b56b4f4ac237b"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classpcs_1_1_cpp_string_t.html">CppStringT</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a86f8c78b2eeb3541fb6b56b4f4ac237b">rstrip</a> () const noexcept</td></tr>
<tr class="memdesc:a86f8c78b2eeb3541fb6b56b4f4ac237b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns a copy of the string with trailing whitespaces removed.  <br /></td></tr>
<tr class="memitem:a89e850d45d6dec167e763cf748a06971" id="r_a89e850d45d6dec167e763cf748a06971"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classpcs_1_1_cpp_string_t.html">CppStringT</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a89e850d45d6dec167e763cf748a06971">rstrip</a> (const <a class="el" href="classpcs_1_1_cpp_string_t.html">CppStringT</a> &amp;removedchars) const noexcept</td></tr>
<tr class="memdesc:a89e850d45d6dec167e763cf748a06971"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns a copy of the string with trailing characters removed.  <br /></td></tr>
<tr class="memitem:a7ca47096b03baa0091c3b0349d210931" id="r_a7ca47096b03baa0091c3b0349d210931"><td class="memItemLeft" align="right" valign="top">std::vector&lt; <a class="el" href="classpcs_1_1_cpp_string_t.html">CppStringT</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a7ca47096b03baa0091c3b0349d210931">split</a> () noexcept</td></tr>
<tr class="memdesc:a7ca47096b03baa0091c3b0349d210931"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns a vector of the words in the whole string, as seperated with whitespace strings.  <br /></td></tr>
<tr class="memitem:acf4d923cfed55cfd90cf12651ce0ac3d" id="r_acf4d923cfed55cfd90cf12651ce0ac3d"><td class="memItemLeft" align="right" valign="top">std::vector&lt; <a class="el" href="classpcs_1_1_cpp_string_t.html">CppStringT</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#acf4d923cfed55cfd90cf12651ce0ac3d">split</a> (const <a class="el" href="classpcs_1_1_cpp_string_t.html">CppStringT</a> &amp;sep) noexcept</td></tr>
<tr class="memdesc:acf4d923cfed55cfd90cf12651ce0ac3d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns a vector of the words in the whole string, using sep as the delimiter string.  <br /></td></tr>
<tr class="memitem:a55a3fa32de834f644ac28d7c2495fa77" id="r_a55a3fa32de834f644ac28d7c2495fa77"><td class="memItemLeft" align="right" valign="top">std::vector&lt; <a class="el" href="classpcs_1_1_cpp_string_t.html">CppStringT</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a55a3fa32de834f644ac28d7c2495fa77">split</a> (const <a class="el" href="classpcs_1_1_cpp_string_t.html">CppStringT</a> &amp;sep, const size_type maxsplit) noexcept</td></tr>
<tr class="memdesc:a55a3fa32de834f644ac28d7c2495fa77"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns a vector of the words in the string, using sep as the delimiter string. At most maxsplit splits are done, the leftmost ones.  <br /></td></tr>
<tr class="memitem:a8fa2afe84d7fc26f96bbd55f4266df2a" id="r_a8fa2afe84d7fc26f96bbd55f4266df2a"><td class="memItemLeft" align="right" valign="top">std::vector&lt; <a class="el" href="classpcs_1_1_cpp_string_t.html">CppStringT</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a8fa2afe84d7fc26f96bbd55f4266df2a">split</a> (const size_type maxsplit) noexcept</td></tr>
<tr class="memdesc:a8fa2afe84d7fc26f96bbd55f4266df2a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns a vector of the words in the string, as seperated with whitespace strings. At most maxsplit splits are done, the leftmost ones.  <br /></td></tr>
<tr class="memitem:a0bd53df14569c307b5ca50a2e1e62960" id="r_a0bd53df14569c307b5ca50a2e1e62960"><td class="memItemLeft" align="right" valign="top">std::vector&lt; <a class="el" href="classpcs_1_1_cpp_string_t.html">CppStringT</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a0bd53df14569c307b5ca50a2e1e62960">splitlines</a> (const bool keep_end=false) const noexcept</td></tr>
<tr class="memdesc:a0bd53df14569c307b5ca50a2e1e62960"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return a list of the lines in the string, breaking at line boundaries.  <br /></td></tr>
<tr class="memitem:ae2f755ae7903586a2086b7b7f943d96e" id="r_ae2f755ae7903586a2086b7b7f943d96e"><td class="memItemLeft" align="right" valign="top">const bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ae2f755ae7903586a2086b7b7f943d96e">startswith</a> (const <a class="el" href="classpcs_1_1_cpp_string_t.html">CppStringT</a> &amp;prefix) const noexcept</td></tr>
<tr class="memdesc:ae2f755ae7903586a2086b7b7f943d96e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns true if the string starts with the specified prefix, otherwise returns false. Test runs on the whole string.  <br /></td></tr>
<tr class="memitem:ad2cfcc7bd22736ebd9f91f04e6a42f8c" id="r_ad2cfcc7bd22736ebd9f91f04e6a42f8c"><td class="memItemLeft" align="right" valign="top">const bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ad2cfcc7bd22736ebd9f91f04e6a42f8c">startswith</a> (const <a class="el" href="classpcs_1_1_cpp_string_t.html">CppStringT</a> &amp;prefix, const size_type start) const noexcept</td></tr>
<tr class="memdesc:ad2cfcc7bd22736ebd9f91f04e6a42f8c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns true if the string starts with the specified prefix, otherwise returns false. Test begins at start position and stops at end of string.  <br /></td></tr>
<tr class="memitem:a5a131c385a01ccc5410d4cffa55cf700" id="r_a5a131c385a01ccc5410d4cffa55cf700"><td class="memItemLeft" align="right" valign="top">const bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a5a131c385a01ccc5410d4cffa55cf700">startswith</a> (const <a class="el" href="classpcs_1_1_cpp_string_t.html">CppStringT</a> &amp;prefix, const size_type start, const size_type end) const noexcept</td></tr>
<tr class="memdesc:a5a131c385a01ccc5410d4cffa55cf700"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns true if the string starts with the specified prefix, otherwise returns false. Test begins at start position and stops at end position.  <br /></td></tr>
<tr class="memitem:a326eb96e19c3559a84af86ff1bf54aa4" id="r_a326eb96e19c3559a84af86ff1bf54aa4"><td class="memItemLeft" align="right" valign="top">const bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a326eb96e19c3559a84af86ff1bf54aa4">startswith</a> (const std::initializer_list&lt; <a class="el" href="classpcs_1_1_cpp_string_t.html">CppStringT</a> &gt; &amp;prefixes, const size_type start, const size_type end) const noexcept</td></tr>
<tr class="memdesc:a326eb96e19c3559a84af86ff1bf54aa4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns true if the string starts with any of the specified prefixes, otherwise returns false. Test begins at start position and stops at end of string.  <br /></td></tr>
<tr class="memitem:ae0865e2c7f8a4871804bf71c1c982dc6" id="r_ae0865e2c7f8a4871804bf71c1c982dc6"><td class="memItemLeft" align="right" valign="top">const bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ae0865e2c7f8a4871804bf71c1c982dc6">startswith_n</a> (const <a class="el" href="classpcs_1_1_cpp_string_t.html">CppStringT</a> &amp;prefix, const size_type <a class="el" href="#a7beda74b4d5092845a970d51d01fe4bf">count</a>) const noexcept</td></tr>
<tr class="memdesc:ae0865e2c7f8a4871804bf71c1c982dc6"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns true if the string starts with the specified suffix, otherwise returns false. Test begins at position 0 and stops after count positions.  <br /></td></tr>
<tr class="memitem:a3b7955f9c7f9452a6a025caaaf0e6d73" id="r_a3b7955f9c7f9452a6a025caaaf0e6d73"><td class="memItemLeft" align="right" valign="top">const bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a3b7955f9c7f9452a6a025caaaf0e6d73">startswith_n</a> (const <a class="el" href="classpcs_1_1_cpp_string_t.html">CppStringT</a> &amp;prefix, const size_type start, const size_type <a class="el" href="#a7beda74b4d5092845a970d51d01fe4bf">count</a>) const noexcept</td></tr>
<tr class="memdesc:a3b7955f9c7f9452a6a025caaaf0e6d73"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns true if the string starts with the specified suffix, otherwise returns false. Test begins at start position and stops after count positions.  <br /></td></tr>
<tr class="memitem:ab2b293c5f1b55af52ceb75b8f7e4d42e" id="r_ab2b293c5f1b55af52ceb75b8f7e4d42e"><td class="memItemLeft" align="right" valign="top">const bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ab2b293c5f1b55af52ceb75b8f7e4d42e">startswith_n</a> (const std::initializer_list&lt; <a class="el" href="classpcs_1_1_cpp_string_t.html">CppStringT</a> &gt; &amp;prefix, const size_type start, const size_type <a class="el" href="#a7beda74b4d5092845a970d51d01fe4bf">count</a>) const noexcept</td></tr>
<tr class="memdesc:ab2b293c5f1b55af52ceb75b8f7e4d42e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns true if the string starts with any of the specified suffixes, otherwise returns false. Test begins at start position and stops after count positions.  <br /></td></tr>
<tr class="memitem:a12bc043347f555b4701e0c70d972058d" id="r_a12bc043347f555b4701e0c70d972058d"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classpcs_1_1_cpp_string_t.html">CppStringT</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a12bc043347f555b4701e0c70d972058d">strip</a> () const noexcept</td></tr>
<tr class="memdesc:a12bc043347f555b4701e0c70d972058d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns a copy of the string with the leading and trailing whitespaces removed.  <br /></td></tr>
<tr class="memitem:a02919129cdf158e75eae1e9815a071bf" id="r_a02919129cdf158e75eae1e9815a071bf"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classpcs_1_1_cpp_string_t.html">CppStringT</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a02919129cdf158e75eae1e9815a071bf">strip</a> (const <a class="el" href="classpcs_1_1_cpp_string_t.html">CppStringT</a> &amp;removedchars) const noexcept</td></tr>
<tr class="memdesc:a02919129cdf158e75eae1e9815a071bf"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns a copy of the string with the leading and trailing characters removed.  <br /></td></tr>
<tr class="memitem:a9debc70420a3fbc7722e3111aeccd819" id="r_a9debc70420a3fbc7722e3111aeccd819"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classpcs_1_1_cpp_string_t.html">CppStringT</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a9debc70420a3fbc7722e3111aeccd819">substr</a> (const size_type start, const size_type <a class="el" href="#a7beda74b4d5092845a970d51d01fe4bf">count</a>=-1) const noexcept</td></tr>
<tr class="memdesc:a9debc70420a3fbc7722e3111aeccd819"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns a copy of the string, starting at index start and ending after count characters.  <br /></td></tr>
<tr class="memitem:a6ab02b4d1c8093a5dfc089a45427f63c" id="r_a6ab02b4d1c8093a5dfc089a45427f63c"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classpcs_1_1_cpp_string_t.html">CppStringT</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a6ab02b4d1c8093a5dfc089a45427f63c">swapcase</a> () const noexcept</td></tr>
<tr class="memdesc:a6ab02b4d1c8093a5dfc089a45427f63c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns a copy of the string with uppercase characters converted to lowercase and vice versa.  <br /></td></tr>
<tr class="memitem:a179634aafb049e8604ca78f813684a28" id="r_a179634aafb049e8604ca78f813684a28"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classpcs_1_1_cpp_string_t.html">CppStringT</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a179634aafb049e8604ca78f813684a28">title</a> () const noexcept</td></tr>
<tr class="memdesc:a179634aafb049e8604ca78f813684a28"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns a titlecased copy of the string where words start with an uppercase character and the remaining characters are lowercase.  <br /></td></tr>
<tr class="memitem:a2a8c1e78b93da9a0abe471c7a8d85090" id="r_a2a8c1e78b93da9a0abe471c7a8d85090"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classpcs_1_1_cpp_string_t.html">CppStringT</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a2a8c1e78b93da9a0abe471c7a8d85090">translate</a> (<a class="el" href="classpcs_1_1_cpp_string_t_1_1_trans_table.html">TransTable</a> &amp;table) noexcept</td></tr>
<tr class="memdesc:a2a8c1e78b93da9a0abe471c7a8d85090"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns a copy of the string in which each character has been mapped through the given translation table.  <br /></td></tr>
<tr class="memitem:a689d2de98f28d131bb0c8b3c87f2f120" id="r_a689d2de98f28d131bb0c8b3c87f2f120"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classpcs_1_1_cpp_string_t.html">CppStringT</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a689d2de98f28d131bb0c8b3c87f2f120">upper</a> () noexcept</td></tr>
<tr class="memdesc:a689d2de98f28d131bb0c8b3c87f2f120"><td class="mdescLeft">&#160;</td><td class="mdescRight">In-place replaces all characters of the string with their uppercase conversion. Returns a reference to string.  <br /></td></tr>
<tr class="memitem:ad3d2b94f37325096205e399b95e9fc5d" id="r_ad3d2b94f37325096205e399b95e9fc5d"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classpcs_1_1_cpp_string_t.html">CppStringT</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ad3d2b94f37325096205e399b95e9fc5d">zfill</a> (const size_type width) const noexcept</td></tr>
<tr class="memdesc:ad3d2b94f37325096205e399b95e9fc5d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns a copy of the string left filled with ASCII '0' digits to make a string of length width.  <br /></td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 id="header-pub-static-methods" class="groupheader"><a id="pub-static-methods" name="pub-static-methods"></a>
Static Public Member Functions</h2></td></tr>
<tr class="memitem:a6b1cfc9713e55a48f036ed030bedc654" id="r_a6b1cfc9713e55a48f036ed030bedc654"><td class="memItemLeft" align="right" valign="top">static const value_type&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a6b1cfc9713e55a48f036ed030bedc654">lower</a> (const value_type ch) noexcept</td></tr>
<tr class="memdesc:a6b1cfc9713e55a48f036ed030bedc654"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns lowercase conversion of the character.  <br /></td></tr>
<tr class="memitem:af5ff8cdba1d90516915e20f93567a9a9" id="r_af5ff8cdba1d90516915e20f93567a9a9"><td class="memItemLeft" align="right" valign="top">static const value_type&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#af5ff8cdba1d90516915e20f93567a9a9">upper</a> (const value_type ch) noexcept</td></tr>
<tr class="memdesc:af5ff8cdba1d90516915e20f93567a9a9"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns uppercase conversion of the character.  <br /></td></tr>
</table>
<a name="details" id="details"></a><h2 id="header-details" class="groupheader">Detailed Description</h2>
<div class="textblock"><div class="compoundTemplParams">template&lt;class CharT, class TraitsT, class AllocatorT&gt;<br />
class pcs::CppStringT&lt; CharT, TraitsT, AllocatorT &gt;</div><p>This is the templated base class for all <a class="el" href="namespacepcs.html#a08d21c458d61442667df24212920d0d9" title="Specialization of basic class with template argument &#39;char&#39;.">CppString</a> classes. </p>
<p>Users should instantiate any specialization of this base class rather than this base class itself:</p><ul>
<li><dl class="section see"><dt>See also</dt><dd><a class="el" href="namespacepcs.html#a08d21c458d61442667df24212920d0d9" title="Specialization of basic class with template argument &#39;char&#39;.">CppString</a> for <a class="el" href="classpcs_1_1_cpp_string_t.html">CppStringT&lt;char&gt;</a>.</dd></dl>
</li>
<li><dl class="section see"><dt>See also</dt><dd><a class="el" href="namespacepcs.html#a79a822cea8e301fd51d2ed51dff57286" title="Specialization of basic class with template argument &#39;wchar_t&#39;.">CppWString</a> for <a class="el" href="classpcs_1_1_cpp_string_t.html">CppStringT&lt;wchar_t&gt;</a>.</dd></dl>
This base class inherits from std::basic_string&lt;CharT&gt;. As such, it gets direct access to all public methods of its base class. <dl class="section see"><dt>See also</dt><dd><a href="https://en.cppreference.com/w/cpp/string/basic_string">https://en.cppreference.com/w/cpp/string/basic_string</a> for a full list of such methods, for instance.</dd></dl>
You may specialize it by your own with any of the next char types:</li>
<li>char8_t (C++20)</li>
<li>char16_t (C++11)</li>
<li>char32_t (C++11) Caution: templated method <a class="el" href="#a5caecc371bf390272283ceb7a15c6c1d" title="Formats this string according to c++20 std::format() specification. Returns this string.">format()</a> may be difficult to specialize with these types --&gt; let us know if you succeed! </li>
</ul>
</div><a name="doc-func-members" id="doc-func-members"></a><h2 id="header-doc-func-members" class="groupheader">Member Function Documentation</h2>
<a id="a48a00cca031b9c29d1912508e120a5f6" name="a48a00cca031b9c29d1912508e120a5f6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a48a00cca031b9c29d1912508e120a5f6">&#9670;&#160;</a></span>capitalize()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class CharT, class TraitsT, class AllocatorT&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classpcs_1_1_cpp_string_t.html">CppStringT</a> <a class="el" href="classpcs_1_1_cpp_string_t.html">pcs::CppStringT</a>&lt; CharT, TraitsT, AllocatorT &gt;::capitalize </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span><span class="mlabel noexcept">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns a copy of the string with its first character capitalized and the rest lowercased. </p>

</div>
</div>
<a id="af18311d8608e71627bc85f96581e4dd3" name="af18311d8608e71627bc85f96581e4dd3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af18311d8608e71627bc85f96581e4dd3">&#9670;&#160;</a></span>center()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class CharT, class TraitsT, class AllocatorT&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classpcs_1_1_cpp_string_t.html">CppStringT</a> <a class="el" href="classpcs_1_1_cpp_string_t.html">pcs::CppStringT</a>&lt; CharT, TraitsT, AllocatorT &gt;::center </td>
          <td>(</td>
          <td class="paramtype">const size_type</td>          <td class="paramname"><span class="paramname"><em>width</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const value_type</td>          <td class="paramname"><span class="paramname"><em>fillch</em></span><span class="paramdefsep"> = </span><span class="paramdefval">value_type('&#160;')</span>&#160;) const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span><span class="mlabel nodiscard">nodiscard</span><span class="mlabel noexcept">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns a copy of the string centered in a string of length width. </p>
<p>Padding is done using the specified fillchar (default is an ASCII space). A copy of the original string is returned if width is less than or equal to the length of the string. The original string remains unchanged. </p>

</div>
</div>
<a id="a0674e29327353aabf83d0e207fed31ed" name="a0674e29327353aabf83d0e207fed31ed"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0674e29327353aabf83d0e207fed31ed">&#9670;&#160;</a></span>contains()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class CharT, class TraitsT, class AllocatorT&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool <a class="el" href="classpcs_1_1_cpp_string_t.html">pcs::CppStringT</a>&lt; CharT, TraitsT, AllocatorT &gt;::contains </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classpcs_1_1_cpp_string_t.html">CppStringT</a>&lt; CharT, TraitsT, AllocatorT &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>substr</em></span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span><span class="mlabel nodiscard">nodiscard</span><span class="mlabel constexpr">constexpr</span><span class="mlabel noexcept">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns true if this string contains the passed string, or false otherwise. </p>
<p>This is a c++ implementation of Python keyword 'in' applied to strings. </p>

<p class="reference">Referenced by <a class="el" href="#a031b05f290f589b2df52bb84252c27c7">pcs::CppStringT&lt; char &gt;::contains_n()</a>.</p>

</div>
</div>
<a id="a031b05f290f589b2df52bb84252c27c7" name="a031b05f290f589b2df52bb84252c27c7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a031b05f290f589b2df52bb84252c27c7">&#9670;&#160;</a></span>contains_n()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class CharT, class TraitsT, class AllocatorT&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool <a class="el" href="classpcs_1_1_cpp_string_t.html">pcs::CppStringT</a>&lt; CharT, TraitsT, AllocatorT &gt;::contains_n </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classpcs_1_1_cpp_string_t.html">CppStringT</a>&lt; CharT, TraitsT, AllocatorT &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>sub</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const size_type</td>          <td class="paramname"><span class="paramname"><em>start</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const size_type</td>          <td class="paramname"><span class="paramname"><em>count</em></span><span class="paramdefsep"> = </span><span class="paramdefval">-1</span>&#160;) const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span><span class="mlabel nodiscard">nodiscard</span><span class="mlabel constexpr">constexpr</span><span class="mlabel noexcept">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns true if the passed string is found within the slice str[start:start+count-1], or false otherwise. </p>
<p>This is a c++ implementation of Python keyword 'in' applied to Python sliced strings. </p>

</div>
</div>
<a id="a7beda74b4d5092845a970d51d01fe4bf" name="a7beda74b4d5092845a970d51d01fe4bf"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7beda74b4d5092845a970d51d01fe4bf">&#9670;&#160;</a></span>count()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class CharT, class TraitsT, class AllocatorT&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">size_type <a class="el" href="classpcs_1_1_cpp_string_t.html">pcs::CppStringT</a>&lt; CharT, TraitsT, AllocatorT &gt;::count </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classpcs_1_1_cpp_string_t.html">CppStringT</a>&lt; CharT, TraitsT, AllocatorT &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>sub</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const size_type</td>          <td class="paramname"><span class="paramname"><em>start</em></span><span class="paramdefsep"> = </span><span class="paramdefval">0</span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const size_type</td>          <td class="paramname"><span class="paramname"><em>end</em></span><span class="paramdefsep"> = </span><span class="paramdefval">-1</span>&#160;) const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span><span class="mlabel nodiscard">nodiscard</span><span class="mlabel constexpr">constexpr</span><span class="mlabel noexcept">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns the number of non-overlapping occurrences of substring sub in the range [start, end]. </p>

<p class="reference">Referenced by <a class="el" href="#a59839e3b5a186c2554224dbf4528c1b4">pcs::CppStringT&lt; char &gt;::count_n()</a>, and <a class="el" href="#a76f97d56e1713182d5e85d58cd445d10">pcs::CppStringT&lt; char &gt;::count_n()</a>.</p>

</div>
</div>
<a id="a59839e3b5a186c2554224dbf4528c1b4" name="a59839e3b5a186c2554224dbf4528c1b4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a59839e3b5a186c2554224dbf4528c1b4">&#9670;&#160;</a></span>count_n() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class CharT, class TraitsT, class AllocatorT&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">size_type <a class="el" href="classpcs_1_1_cpp_string_t.html">pcs::CppStringT</a>&lt; CharT, TraitsT, AllocatorT &gt;::count_n </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classpcs_1_1_cpp_string_t.html">CppStringT</a>&lt; CharT, TraitsT, AllocatorT &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>sub</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const size_type</td>          <td class="paramname"><span class="paramname"><em>length</em></span>&#160;) const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span><span class="mlabel nodiscard">nodiscard</span><span class="mlabel constexpr">constexpr</span><span class="mlabel noexcept">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns the number of non-overlapping occurrences of substring sub in the range [0, length-1]. </p>

</div>
</div>
<a id="a76f97d56e1713182d5e85d58cd445d10" name="a76f97d56e1713182d5e85d58cd445d10"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a76f97d56e1713182d5e85d58cd445d10">&#9670;&#160;</a></span>count_n() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class CharT, class TraitsT, class AllocatorT&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">size_type <a class="el" href="classpcs_1_1_cpp_string_t.html">pcs::CppStringT</a>&lt; CharT, TraitsT, AllocatorT &gt;::count_n </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classpcs_1_1_cpp_string_t.html">CppStringT</a>&lt; CharT, TraitsT, AllocatorT &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>sub</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const size_type</td>          <td class="paramname"><span class="paramname"><em>start</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const size_type</td>          <td class="paramname"><span class="paramname"><em>length</em></span>&#160;) const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span><span class="mlabel nodiscard">nodiscard</span><span class="mlabel constexpr">constexpr</span><span class="mlabel noexcept">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns the number of non-overlapping occurrences of substring sub in the range [start, start+length-1]. </p>

</div>
</div>
<a id="a3e9da0bfa54e84420e81668f6ce7f52c" name="a3e9da0bfa54e84420e81668f6ce7f52c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3e9da0bfa54e84420e81668f6ce7f52c">&#9670;&#160;</a></span>endswith() <span class="overload">[1/4]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class CharT, class TraitsT, class AllocatorT&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const bool <a class="el" href="classpcs_1_1_cpp_string_t.html">pcs::CppStringT</a>&lt; CharT, TraitsT, AllocatorT &gt;::endswith </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classpcs_1_1_cpp_string_t.html">CppStringT</a>&lt; CharT, TraitsT, AllocatorT &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>suffix</em></span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span><span class="mlabel nodiscard">nodiscard</span><span class="mlabel noexcept">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns true if the string ends with the specified suffix, otherwise returns false. Test runs on the whole string. </p>

</div>
</div>
<a id="a6b23210d7d5eb07c9f942d62cc76b05e" name="a6b23210d7d5eb07c9f942d62cc76b05e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6b23210d7d5eb07c9f942d62cc76b05e">&#9670;&#160;</a></span>endswith() <span class="overload">[2/4]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class CharT, class TraitsT, class AllocatorT&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const bool <a class="el" href="classpcs_1_1_cpp_string_t.html">pcs::CppStringT</a>&lt; CharT, TraitsT, AllocatorT &gt;::endswith </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classpcs_1_1_cpp_string_t.html">CppStringT</a>&lt; CharT, TraitsT, AllocatorT &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>suffix</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const size_type</td>          <td class="paramname"><span class="paramname"><em>end</em></span>&#160;) const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span><span class="mlabel nodiscard">nodiscard</span><span class="mlabel noexcept">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns true if the string ends with the specified suffix, otherwise returns false. Test begins at start of string and stops at end position. </p>

</div>
</div>
<a id="a42f1e87d7f1903536ee79aa058d5c867" name="a42f1e87d7f1903536ee79aa058d5c867"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a42f1e87d7f1903536ee79aa058d5c867">&#9670;&#160;</a></span>endswith() <span class="overload">[3/4]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class CharT, class TraitsT, class AllocatorT&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const bool <a class="el" href="classpcs_1_1_cpp_string_t.html">pcs::CppStringT</a>&lt; CharT, TraitsT, AllocatorT &gt;::endswith </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classpcs_1_1_cpp_string_t.html">CppStringT</a>&lt; CharT, TraitsT, AllocatorT &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>suffix</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const size_type</td>          <td class="paramname"><span class="paramname"><em>start</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const size_type</td>          <td class="paramname"><span class="paramname"><em>end</em></span>&#160;) const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span><span class="mlabel nodiscard">nodiscard</span><span class="mlabel noexcept">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns true if the string ends with the specified suffix, otherwise returns false. Test begins at start position and stops at end position. </p>

<p class="reference">Referenced by <a class="el" href="#a619935926ef961883e9bbd92b2fc23bd">pcs::CppStringT&lt; char &gt;::endswith_n()</a>, <a class="el" href="#a7eca5636b598c6fc107452ddd04a2f17">pcs::CppStringT&lt; char &gt;::endswith_n()</a>, <a class="el" href="#a4fd91047ab0126c823aa391a699e03bf">pcs::CppStringT&lt; char &gt;::endswith_n()</a>, and <a class="el" href="#ad6a8dc124ab8b7cab1cb328240763ed0">pcs::CppStringT&lt; char &gt;::removesuffix()</a>.</p>

</div>
</div>
<a id="a87b25fce2a05421efd718c599a784a09" name="a87b25fce2a05421efd718c599a784a09"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a87b25fce2a05421efd718c599a784a09">&#9670;&#160;</a></span>endswith() <span class="overload">[4/4]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class CharT, class TraitsT, class AllocatorT&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const bool <a class="el" href="classpcs_1_1_cpp_string_t.html">pcs::CppStringT</a>&lt; CharT, TraitsT, AllocatorT &gt;::endswith </td>
          <td>(</td>
          <td class="paramtype">const std::initializer_list&lt; <a class="el" href="classpcs_1_1_cpp_string_t.html">CppStringT</a>&lt; CharT, TraitsT, AllocatorT &gt; &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>suffixes</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const size_type</td>          <td class="paramname"><span class="paramname"><em>start</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const size_type</td>          <td class="paramname"><span class="paramname"><em>end</em></span>&#160;) const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span><span class="mlabel nodiscard">nodiscard</span><span class="mlabel noexcept">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns true if the string ends with any of the specified suffixes, otherwise returns false. Test begins at start position and stops at end position. </p>

</div>
</div>
<a id="a619935926ef961883e9bbd92b2fc23bd" name="a619935926ef961883e9bbd92b2fc23bd"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a619935926ef961883e9bbd92b2fc23bd">&#9670;&#160;</a></span>endswith_n() <span class="overload">[1/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class CharT, class TraitsT, class AllocatorT&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const bool <a class="el" href="classpcs_1_1_cpp_string_t.html">pcs::CppStringT</a>&lt; CharT, TraitsT, AllocatorT &gt;::endswith_n </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classpcs_1_1_cpp_string_t.html">CppStringT</a>&lt; CharT, TraitsT, AllocatorT &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>suffix</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const size_type</td>          <td class="paramname"><span class="paramname"><em>count</em></span>&#160;) const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span><span class="mlabel nodiscard">nodiscard</span><span class="mlabel noexcept">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns true if the string ends with the specified suffix, otherwise returns false. Test begins at position 0 and stops after count positions. </p>

</div>
</div>
<a id="a7eca5636b598c6fc107452ddd04a2f17" name="a7eca5636b598c6fc107452ddd04a2f17"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7eca5636b598c6fc107452ddd04a2f17">&#9670;&#160;</a></span>endswith_n() <span class="overload">[2/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class CharT, class TraitsT, class AllocatorT&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const bool <a class="el" href="classpcs_1_1_cpp_string_t.html">pcs::CppStringT</a>&lt; CharT, TraitsT, AllocatorT &gt;::endswith_n </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classpcs_1_1_cpp_string_t.html">CppStringT</a>&lt; CharT, TraitsT, AllocatorT &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>suffix</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const size_type</td>          <td class="paramname"><span class="paramname"><em>start</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const size_type</td>          <td class="paramname"><span class="paramname"><em>count</em></span>&#160;) const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span><span class="mlabel nodiscard">nodiscard</span><span class="mlabel noexcept">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns true if the string ends with the specified suffix, otherwise returns false. Test begins at start position and stops after count positions. </p>

</div>
</div>
<a id="a4fd91047ab0126c823aa391a699e03bf" name="a4fd91047ab0126c823aa391a699e03bf"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4fd91047ab0126c823aa391a699e03bf">&#9670;&#160;</a></span>endswith_n() <span class="overload">[3/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class CharT, class TraitsT, class AllocatorT&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const bool <a class="el" href="classpcs_1_1_cpp_string_t.html">pcs::CppStringT</a>&lt; CharT, TraitsT, AllocatorT &gt;::endswith_n </td>
          <td>(</td>
          <td class="paramtype">const std::initializer_list&lt; <a class="el" href="classpcs_1_1_cpp_string_t.html">CppStringT</a>&lt; CharT, TraitsT, AllocatorT &gt; &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>suffixes</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const size_type</td>          <td class="paramname"><span class="paramname"><em>start</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const size_type</td>          <td class="paramname"><span class="paramname"><em>count</em></span>&#160;) const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span><span class="mlabel nodiscard">nodiscard</span><span class="mlabel noexcept">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns true if the string ends with any of the specified suffixes, otherwise returns false. Test begins at start position and stops after count positions. </p>

</div>
</div>
<a id="a2cc04d5062162ff5f7b6111d6f1e78e8" name="a2cc04d5062162ff5f7b6111d6f1e78e8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2cc04d5062162ff5f7b6111d6f1e78e8">&#9670;&#160;</a></span>expand_tabs()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class CharT, class TraitsT, class AllocatorT&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classpcs_1_1_cpp_string_t.html">CppStringT</a> <a class="el" href="classpcs_1_1_cpp_string_t.html">pcs::CppStringT</a>&lt; CharT, TraitsT, AllocatorT &gt;::expand_tabs </td>
          <td>(</td>
          <td class="paramtype">const size_type</td>          <td class="paramname"><span class="paramname"><em>tabsize</em></span><span class="paramdefsep"> = </span><span class="paramdefval">8</span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span><span class="mlabel nodiscard">nodiscard</span><span class="mlabel noexcept">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns a copy of the string where all tab characters are replaced by one or more spaces, depending on the current column and the given tab size. </p>

</div>
</div>
<a id="a24c4b7a0f713373cb3287d92289562ad" name="a24c4b7a0f713373cb3287d92289562ad"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a24c4b7a0f713373cb3287d92289562ad">&#9670;&#160;</a></span>find()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class CharT, class TraitsT, class AllocatorT&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">size_type <a class="el" href="classpcs_1_1_cpp_string_t.html">pcs::CppStringT</a>&lt; CharT, TraitsT, AllocatorT &gt;::find </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classpcs_1_1_cpp_string_t.html">CppStringT</a>&lt; CharT, TraitsT, AllocatorT &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>sub</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const size_type</td>          <td class="paramname"><span class="paramname"><em>start</em></span><span class="paramdefsep"> = </span><span class="paramdefval">0</span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const size_type</td>          <td class="paramname"><span class="paramname"><em>end</em></span><span class="paramdefsep"> = </span><span class="paramdefval">-1</span>&#160;) const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span><span class="mlabel nodiscard">nodiscard</span><span class="mlabel constexpr">constexpr</span><span class="mlabel noexcept">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns the lowest index in the string where substring sub is found within the slice str[start:end], or -1 (i.e. 'npos') if sub is not found. </p>
<p>Note: this method should be used only if you need to know the position of sub. To check if sub is a substring or not, use the method <a class="el" href="#a0674e29327353aabf83d0e207fed31ed" title="Returns true if this string contains the passed string, or false otherwise.">contains()</a>.</p>
<p>CAUTION: empty substrings are considered to be in the string if start and end positions are both less than the string size and if start &lt;= end.</p>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="#ac4c9351bb52eb9a62fa7fb2e2d5f054d" title="Returns the lowest index in the string where substring sub is found within the slice str[start:start+...">find_n()</a>, <a class="el" href="#af363308ba741b267641e1aa35669d603" title="Returns the highest index in the string where substring sub is found within the slice str[start:end],...">rfind()</a> and <a class="el" href="#a519a292eb3f0790d54a59a201f2d6410" title="Returns the highest index in the string where substring sub is found within the slice str[start:start...">rfind_n()</a>. </dd>
<dd>
<a class="el" href="#a277a2b8a3b93951ccb94b6bf39daa582" title="Like find(const CppStringT&amp;), but raises NotFoundException when the substring sub is not found.">index()</a>, <a class="el" href="#aee94d4b52483021051b168e776b18569" title="Like find_n(sub, start, count), but raises NotFoundException when the substring is not found.">index_n()</a>, <a class="el" href="#a6693ec49258c6ac80a7875b3ebf3c916" title="Like rfind(sub, start, end), but raises NotFoundException when the substring is not found.">rindex()</a> and <a class="el" href="#afc08a4e91b93710838c8f0d6234e057e" title="Like rfind_n(sub, start, count), but raises NotFoundException when the substring is not found.">rindex_n()</a>. </dd></dl>

<p class="reference">Referenced by <a class="el" href="#a7beda74b4d5092845a970d51d01fe4bf">pcs::CppStringT&lt; char &gt;::count()</a>, <a class="el" href="#a277a2b8a3b93951ccb94b6bf39daa582">pcs::CppStringT&lt; char &gt;::index()</a>, <a class="el" href="#ac5f88b0fc1f33cda23c30cb1f3bc560f">pcs::CppStringT&lt; char &gt;::partition()</a>, <a class="el" href="#ad4f39683db649aa8a65907268c499f02">pcs::CppStringT&lt; char &gt;::replace()</a>, and <a class="el" href="#a55a3fa32de834f644ac28d7c2495fa77">pcs::CppStringT&lt; char &gt;::split()</a>.</p>

</div>
</div>
<a id="a6b0bc87b284120d0d3bfc685984997c0" name="a6b0bc87b284120d0d3bfc685984997c0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6b0bc87b284120d0d3bfc685984997c0">&#9670;&#160;</a></span>find_n() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class CharT, class TraitsT, class AllocatorT&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">size_type <a class="el" href="classpcs_1_1_cpp_string_t.html">pcs::CppStringT</a>&lt; CharT, TraitsT, AllocatorT &gt;::find_n </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classpcs_1_1_cpp_string_t.html">CppStringT</a>&lt; CharT, TraitsT, AllocatorT &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>sub</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const size_type</td>          <td class="paramname"><span class="paramname"><em>count</em></span>&#160;) const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span><span class="mlabel nodiscard">nodiscard</span><span class="mlabel constexpr">constexpr</span><span class="mlabel noexcept">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns the lowest index in the string where substring sub is found within the slice str[0:count-1], or -1 (i.e. 'npos') if sub is not found. </p>
<p>Note: this method should be used only if you need to know the position of sub. To check if sub is a substring or not, use the method <a class="el" href="#a031b05f290f589b2df52bb84252c27c7" title="Returns true if the passed string is found within the slice str[start:start+count-1],...">contains_n()</a>.</p>
<p>CAUTION: empty substrings are considered to be in the string if start and end positions are both less than the string size and if start &lt;= end. The returned position is 0.</p>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="#a24c4b7a0f713373cb3287d92289562ad" title="Returns the lowest index in the string where substring sub is found within the slice str[start:end],...">find()</a>, <a class="el" href="#af363308ba741b267641e1aa35669d603" title="Returns the highest index in the string where substring sub is found within the slice str[start:end],...">rfind()</a> and <a class="el" href="#a519a292eb3f0790d54a59a201f2d6410" title="Returns the highest index in the string where substring sub is found within the slice str[start:start...">rfind_n()</a>. </dd>
<dd>
<a class="el" href="#a277a2b8a3b93951ccb94b6bf39daa582" title="Like find(const CppStringT&amp;), but raises NotFoundException when the substring sub is not found.">index()</a>, <a class="el" href="#aee94d4b52483021051b168e776b18569" title="Like find_n(sub, start, count), but raises NotFoundException when the substring is not found.">index_n()</a>, <a class="el" href="#a6693ec49258c6ac80a7875b3ebf3c916" title="Like rfind(sub, start, end), but raises NotFoundException when the substring is not found.">rindex()</a> and <a class="el" href="#afc08a4e91b93710838c8f0d6234e057e" title="Like rfind_n(sub, start, count), but raises NotFoundException when the substring is not found.">rindex_n()</a>. </dd></dl>

</div>
</div>
<a id="ac4c9351bb52eb9a62fa7fb2e2d5f054d" name="ac4c9351bb52eb9a62fa7fb2e2d5f054d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac4c9351bb52eb9a62fa7fb2e2d5f054d">&#9670;&#160;</a></span>find_n() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class CharT, class TraitsT, class AllocatorT&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">size_type <a class="el" href="classpcs_1_1_cpp_string_t.html">pcs::CppStringT</a>&lt; CharT, TraitsT, AllocatorT &gt;::find_n </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classpcs_1_1_cpp_string_t.html">CppStringT</a>&lt; CharT, TraitsT, AllocatorT &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>sub</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const size_type</td>          <td class="paramname"><span class="paramname"><em>start</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const size_type</td>          <td class="paramname"><span class="paramname"><em>count</em></span>&#160;) const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span><span class="mlabel nodiscard">nodiscard</span><span class="mlabel constexpr">constexpr</span><span class="mlabel noexcept">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns the lowest index in the string where substring sub is found within the slice str[start:start+count-1], or -1 (i.e. 'npos') if sub is not found. </p>
<p>Note: this method should be used only if you need to know the position of sub. To check if sub is a substring or not, use the method <a class="el" href="#a031b05f290f589b2df52bb84252c27c7" title="Returns true if the passed string is found within the slice str[start:start+count-1],...">contains_n()</a>.</p>
<p>CAUTION: empty substrings are considered to be in the string if start and end positions are both less than the string size and if start &lt;= end. The returned position is 0.</p>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="#a24c4b7a0f713373cb3287d92289562ad" title="Returns the lowest index in the string where substring sub is found within the slice str[start:end],...">find()</a>, <a class="el" href="#af363308ba741b267641e1aa35669d603" title="Returns the highest index in the string where substring sub is found within the slice str[start:end],...">rfind()</a> and <a class="el" href="#a519a292eb3f0790d54a59a201f2d6410" title="Returns the highest index in the string where substring sub is found within the slice str[start:start...">rfind_n()</a>. </dd>
<dd>
<a class="el" href="#a277a2b8a3b93951ccb94b6bf39daa582" title="Like find(const CppStringT&amp;), but raises NotFoundException when the substring sub is not found.">index()</a>, <a class="el" href="#aee94d4b52483021051b168e776b18569" title="Like find_n(sub, start, count), but raises NotFoundException when the substring is not found.">index_n()</a>, <a class="el" href="#a6693ec49258c6ac80a7875b3ebf3c916" title="Like rfind(sub, start, end), but raises NotFoundException when the substring is not found.">rindex()</a> and <a class="el" href="#afc08a4e91b93710838c8f0d6234e057e" title="Like rfind_n(sub, start, count), but raises NotFoundException when the substring is not found.">rindex_n()</a>. </dd></dl>

<p class="reference">Referenced by <a class="el" href="#a24c4b7a0f713373cb3287d92289562ad">pcs::CppStringT&lt; char &gt;::find()</a>, and <a class="el" href="#a6b0bc87b284120d0d3bfc685984997c0">pcs::CppStringT&lt; char &gt;::find_n()</a>.</p>

</div>
</div>
<a id="a1a89389b38fd6af3ea8db3489dd82f70" name="a1a89389b38fd6af3ea8db3489dd82f70"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1a89389b38fd6af3ea8db3489dd82f70">&#9670;&#160;</a></span>format() <span class="overload">[1/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class CharT, class TraitsT, class AllocatorT&gt; </div>
<div class="memtemplate">
template&lt;class... ArgsT&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classpcs_1_1_cpp_string_t.html">CppStringT</a> &amp; <a class="el" href="classpcs_1_1_cpp_string_t.html">pcs::CppStringT</a>&lt; CharT, TraitsT, AllocatorT &gt;::format </td>
          <td>(</td>
          <td class="paramtype">const std::basic_format_string&lt; char, std::type_identity_t&lt; ArgsT &gt;... &gt;</td>          <td class="paramname"><span class="paramname"><em>frmt</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">ArgsT &amp;&amp;...</td>          <td class="paramname"><span class="paramname"><em>args</em></span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">frmt</td><td>specialzation for char's </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a5caecc371bf390272283ceb7a15c6c1d" name="a5caecc371bf390272283ceb7a15c6c1d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5caecc371bf390272283ceb7a15c6c1d">&#9670;&#160;</a></span>format() <span class="overload">[2/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class CharT, class TraitsT, class AllocatorT&gt; </div>
<div class="memtemplate">
template&lt;typename T, class... ArgsT&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classpcs_1_1_cpp_string_t.html">CppStringT</a> &amp; <a class="el" href="classpcs_1_1_cpp_string_t.html">pcs::CppStringT</a>&lt; CharT, TraitsT, AllocatorT &gt;::format </td>
          <td>(</td>
          <td class="paramtype">const std::basic_format_string&lt; T, std::type_identity_t&lt; ArgsT &gt;... &gt;</td>          <td class="paramname"><span class="paramname"><em>frmt</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">ArgsT &amp;&amp;...</td>          <td class="paramname"><span class="paramname"><em>args</em></span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Formats this string according to c++20 std::format() specification. Returns this string. </p>

</div>
</div>
<a id="a944e066f3a863c354a5613a6eda17374" name="a944e066f3a863c354a5613a6eda17374"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a944e066f3a863c354a5613a6eda17374">&#9670;&#160;</a></span>format() <span class="overload">[3/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class CharT, class TraitsT, class AllocatorT&gt; </div>
<div class="memtemplate">
template&lt;class... ArgsT&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classpcs_1_1_cpp_string_t.html">CppStringT</a> &amp; <a class="el" href="classpcs_1_1_cpp_string_t.html">pcs::CppStringT</a>&lt; CharT, TraitsT, AllocatorT &gt;::format </td>
          <td>(</td>
          <td class="paramtype">const std::basic_format_string&lt; wchar_t, std::type_identity_t&lt; ArgsT &gt;... &gt;</td>          <td class="paramname"><span class="paramname"><em>frmt</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">ArgsT &amp;&amp;...</td>          <td class="paramname"><span class="paramname"><em>args</em></span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">frmt</td><td>specialzation for wchar_t's </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a277a2b8a3b93951ccb94b6bf39daa582" name="a277a2b8a3b93951ccb94b6bf39daa582"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a277a2b8a3b93951ccb94b6bf39daa582">&#9670;&#160;</a></span>index()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class CharT, class TraitsT, class AllocatorT&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">size_type <a class="el" href="classpcs_1_1_cpp_string_t.html">pcs::CppStringT</a>&lt; CharT, TraitsT, AllocatorT &gt;::index </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classpcs_1_1_cpp_string_t.html">CppStringT</a>&lt; CharT, TraitsT, AllocatorT &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>sub</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const size_type</td>          <td class="paramname"><span class="paramname"><em>start</em></span><span class="paramdefsep"> = </span><span class="paramdefval">0</span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const size_type</td>          <td class="paramname"><span class="paramname"><em>end</em></span><span class="paramdefsep"> = </span><span class="paramdefval">-1</span>&#160;) const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span><span class="mlabel nodiscard">nodiscard</span><span class="mlabel constexpr">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Like find(const CppStringT&amp;), but raises <a class="el" href="classpcs_1_1_cpp_string_t_1_1_not_found_exception.html">NotFoundException</a> when the substring sub is not found. </p>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="#aee94d4b52483021051b168e776b18569" title="Like find_n(sub, start, count), but raises NotFoundException when the substring is not found.">index_n()</a>, <a class="el" href="#a6693ec49258c6ac80a7875b3ebf3c916" title="Like rfind(sub, start, end), but raises NotFoundException when the substring is not found.">rindex()</a> and <a class="el" href="#afc08a4e91b93710838c8f0d6234e057e" title="Like rfind_n(sub, start, count), but raises NotFoundException when the substring is not found.">rindex_n()</a>. </dd>
<dd>
<a class="el" href="#a24c4b7a0f713373cb3287d92289562ad" title="Returns the lowest index in the string where substring sub is found within the slice str[start:end],...">find()</a>, <a class="el" href="#ac4c9351bb52eb9a62fa7fb2e2d5f054d" title="Returns the lowest index in the string where substring sub is found within the slice str[start:start+...">find_n()</a>, <a class="el" href="#af363308ba741b267641e1aa35669d603" title="Returns the highest index in the string where substring sub is found within the slice str[start:end],...">rfind()</a> and <a class="el" href="#a519a292eb3f0790d54a59a201f2d6410" title="Returns the highest index in the string where substring sub is found within the slice str[start:start...">rfind_n()</a>. </dd></dl>

<p class="reference">Referenced by <a class="el" href="#a19a51054b824add817f30c5ff03effe7">pcs::CppStringT&lt; char &gt;::index_n()</a>, and <a class="el" href="#aee94d4b52483021051b168e776b18569">pcs::CppStringT&lt; char &gt;::index_n()</a>.</p>

</div>
</div>
<a id="a19a51054b824add817f30c5ff03effe7" name="a19a51054b824add817f30c5ff03effe7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a19a51054b824add817f30c5ff03effe7">&#9670;&#160;</a></span>index_n() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class CharT, class TraitsT, class AllocatorT&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">size_type <a class="el" href="classpcs_1_1_cpp_string_t.html">pcs::CppStringT</a>&lt; CharT, TraitsT, AllocatorT &gt;::index_n </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classpcs_1_1_cpp_string_t.html">CppStringT</a>&lt; CharT, TraitsT, AllocatorT &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>sub</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const size_type</td>          <td class="paramname"><span class="paramname"><em>count</em></span>&#160;) const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span><span class="mlabel nodiscard">nodiscard</span><span class="mlabel constexpr">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Like find_n(sub, count), but raises <a class="el" href="classpcs_1_1_cpp_string_t_1_1_not_found_exception.html">NotFoundException</a> when the substring is not found. </p>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="#aee94d4b52483021051b168e776b18569" title="Like find_n(sub, start, count), but raises NotFoundException when the substring is not found.">index_n()</a>, <a class="el" href="#a6693ec49258c6ac80a7875b3ebf3c916" title="Like rfind(sub, start, end), but raises NotFoundException when the substring is not found.">rindex()</a> and <a class="el" href="#afc08a4e91b93710838c8f0d6234e057e" title="Like rfind_n(sub, start, count), but raises NotFoundException when the substring is not found.">rindex_n()</a>. </dd>
<dd>
<a class="el" href="#a24c4b7a0f713373cb3287d92289562ad" title="Returns the lowest index in the string where substring sub is found within the slice str[start:end],...">find()</a>, <a class="el" href="#ac4c9351bb52eb9a62fa7fb2e2d5f054d" title="Returns the lowest index in the string where substring sub is found within the slice str[start:start+...">find_n()</a>, <a class="el" href="#af363308ba741b267641e1aa35669d603" title="Returns the highest index in the string where substring sub is found within the slice str[start:end],...">rfind()</a> and <a class="el" href="#a519a292eb3f0790d54a59a201f2d6410" title="Returns the highest index in the string where substring sub is found within the slice str[start:start...">rfind_n()</a>. </dd></dl>

</div>
</div>
<a id="aee94d4b52483021051b168e776b18569" name="aee94d4b52483021051b168e776b18569"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aee94d4b52483021051b168e776b18569">&#9670;&#160;</a></span>index_n() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class CharT, class TraitsT, class AllocatorT&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">size_type <a class="el" href="classpcs_1_1_cpp_string_t.html">pcs::CppStringT</a>&lt; CharT, TraitsT, AllocatorT &gt;::index_n </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classpcs_1_1_cpp_string_t.html">CppStringT</a>&lt; CharT, TraitsT, AllocatorT &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>sub</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const size_type</td>          <td class="paramname"><span class="paramname"><em>start</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const size_type</td>          <td class="paramname"><span class="paramname"><em>count</em></span>&#160;) const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span><span class="mlabel nodiscard">nodiscard</span><span class="mlabel constexpr">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Like find_n(sub, start, count), but raises <a class="el" href="classpcs_1_1_cpp_string_t_1_1_not_found_exception.html">NotFoundException</a> when the substring is not found. </p>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="#aee94d4b52483021051b168e776b18569" title="Like find_n(sub, start, count), but raises NotFoundException when the substring is not found.">index_n()</a>, <a class="el" href="#a6693ec49258c6ac80a7875b3ebf3c916" title="Like rfind(sub, start, end), but raises NotFoundException when the substring is not found.">rindex()</a> and <a class="el" href="#afc08a4e91b93710838c8f0d6234e057e" title="Like rfind_n(sub, start, count), but raises NotFoundException when the substring is not found.">rindex_n()</a>. </dd>
<dd>
<a class="el" href="#a24c4b7a0f713373cb3287d92289562ad" title="Returns the lowest index in the string where substring sub is found within the slice str[start:end],...">find()</a>, <a class="el" href="#ac4c9351bb52eb9a62fa7fb2e2d5f054d" title="Returns the lowest index in the string where substring sub is found within the slice str[start:start+...">find_n()</a>, <a class="el" href="#af363308ba741b267641e1aa35669d603" title="Returns the highest index in the string where substring sub is found within the slice str[start:end],...">rfind()</a> and <a class="el" href="#a519a292eb3f0790d54a59a201f2d6410" title="Returns the highest index in the string where substring sub is found within the slice str[start:start...">rfind_n()</a>. </dd></dl>

</div>
</div>
<a id="a7565e4f2958e485ee2b0815be1faa0fa" name="a7565e4f2958e485ee2b0815be1faa0fa"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7565e4f2958e485ee2b0815be1faa0fa">&#9670;&#160;</a></span>is_words_sep()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class CharT, class TraitsT, class AllocatorT&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const bool <a class="el" href="classpcs_1_1_cpp_string_t.html">pcs::CppStringT</a>&lt; CharT, TraitsT, AllocatorT &gt;::is_words_sep </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span><span class="mlabel nodiscard">nodiscard</span><span class="mlabel noexcept">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns true if there are only whitespace and punctuation characters in the string and there is at least one character, or false otherwise. </p>

</div>
</div>
<a id="a8fdf96ffee524d5b795c4aad26ece6ae" name="a8fdf96ffee524d5b795c4aad26ece6ae"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8fdf96ffee524d5b795c4aad26ece6ae">&#9670;&#160;</a></span>isalnum()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class CharT, class TraitsT, class AllocatorT&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const bool <a class="el" href="classpcs_1_1_cpp_string_t.html">pcs::CppStringT</a>&lt; CharT, TraitsT, AllocatorT &gt;::isalnum </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span><span class="mlabel nodiscard">nodiscard</span><span class="mlabel noexcept">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns true if all characters in the string are alphanumeric and there is at least one character, or false otherwise. </p>

</div>
</div>
<a id="a447b7c58b4be1cdcba3aedf189acbce7" name="a447b7c58b4be1cdcba3aedf189acbce7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a447b7c58b4be1cdcba3aedf189acbce7">&#9670;&#160;</a></span>isalpha()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class CharT, class TraitsT, class AllocatorT&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const bool <a class="el" href="classpcs_1_1_cpp_string_t.html">pcs::CppStringT</a>&lt; CharT, TraitsT, AllocatorT &gt;::isalpha </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span><span class="mlabel nodiscard">nodiscard</span><span class="mlabel noexcept">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns true if all characters in the string are alphabetic and there is at least one character, or false otherwise. </p>

</div>
</div>
<a id="a710631f31d4c63c2117e8f4804fad3f2" name="a710631f31d4c63c2117e8f4804fad3f2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a710631f31d4c63c2117e8f4804fad3f2">&#9670;&#160;</a></span>isascii()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class CharT, class TraitsT, class AllocatorT&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const bool <a class="el" href="classpcs_1_1_cpp_string_t.html">pcs::CppStringT</a>&lt; CharT, TraitsT, AllocatorT &gt;::isascii </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span><span class="mlabel nodiscard">nodiscard</span><span class="mlabel noexcept">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns true if the string is empty or all characters in the string are ASCII, or false otherwise. </p>

</div>
</div>
<a id="a0b9d8a55419274e7cfd9badb4df704e3" name="a0b9d8a55419274e7cfd9badb4df704e3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0b9d8a55419274e7cfd9badb4df704e3">&#9670;&#160;</a></span>isdecimal()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class CharT, class TraitsT, class AllocatorT&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const bool <a class="el" href="classpcs_1_1_cpp_string_t.html">pcs::CppStringT</a>&lt; CharT, TraitsT, AllocatorT &gt;::isdecimal </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span><span class="mlabel nodiscard">nodiscard</span><span class="mlabel noexcept">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns true if all characters in the string are decimal characters and there is at least one character, or false otherwise. </p>
<p>Decimal characters are those that can be used to form numbers in base 10, e.g. U+0660, ARABIC-INDIC DIGIT ZERO. Formally a decimal character is a character in the Unicode General Category Nd. </p>

<p class="reference">Referenced by <a class="el" href="#a21316d00180377a3f48910a6c4c43b9c">pcs::CppStringT&lt; char &gt;::isdigit()</a>, and <a class="el" href="#a578176ed20fd8da965afbcae1d99dd59">pcs::CppStringT&lt; char &gt;::isnumeric()</a>.</p>

</div>
</div>
<a id="a21316d00180377a3f48910a6c4c43b9c" name="a21316d00180377a3f48910a6c4c43b9c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a21316d00180377a3f48910a6c4c43b9c">&#9670;&#160;</a></span>isdigit()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class CharT, class TraitsT, class AllocatorT&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const bool <a class="el" href="classpcs_1_1_cpp_string_t.html">pcs::CppStringT</a>&lt; CharT, TraitsT, AllocatorT &gt;::isdigit </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span><span class="mlabel nodiscard">nodiscard</span><span class="mlabel noexcept">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns true if all characters in the string are digits and there is at least one character, or false otherwise. </p>
<p>Digits include decimal characters and digits that need special handling, such as the compatibility superscript digits. This covers digits which cannot be used to form numbers in base 10, like the Kharosthi numbers. Formally, a digit is a character that has the property value Numeric_Type=Digit or Numeric_Type =Decimal.</p>
<p>CAUTION: current implementation of library cpp-strings does not implement above algorithm. It just returns the same result as '<a class="el" href="#a0b9d8a55419274e7cfd9badb4df704e3" title="Returns true if all characters in the string are decimal characters and there is at least one charact...">isdecimal()</a>' which is NOT what Python str library does. </p>

</div>
</div>
<a id="a91f72d425dbb4c53a066338d30683246" name="a91f72d425dbb4c53a066338d30683246"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a91f72d425dbb4c53a066338d30683246">&#9670;&#160;</a></span>isidentifier()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class CharT, class TraitsT, class AllocatorT&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const bool <a class="el" href="classpcs_1_1_cpp_string_t.html">pcs::CppStringT</a>&lt; CharT, TraitsT, AllocatorT &gt;::isidentifier </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span><span class="mlabel nodiscard">nodiscard</span><span class="mlabel noexcept">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns true if the string is not empty and is a valid identifier according to the language definition, or false otherwise. </p>
<p>CAUTION: the current implementation of this method does not deal with the proper c++ defintiion of identifiers (see <a href="https://en.cppreference.com/w/cpp/language/identifiers">https://en.cppreference.com/w/cpp/language/identifiers</a> and <a href="https://www.unicode.org/reports/tr31/#Table_Lexical_Classes_for_Identifiers">https://www.unicode.org/reports/tr31/#Table_Lexical_Classes_for_Identifiers</a>).</p>
<p>While the specification of identifiers in c++ is this one:</p>
<p>identifier ::= XID_Start XID_Continue* XID_Start ::= ID_Start XID_Continue* ID_Start ::= &lt;characters derived from the Unicode General_Category of uppercase letters, lowercase letters, titlecase letters, modifier letters, other letters, letter numbers, plus Other_ID_Start, minus Pattern_Syntax and Pattern_White_Space code points&gt; XID_Continue ::= &lt;characters derived from ID_Continue as per Unicode specs Section 5.1, NFKC Modifications (<a href="https://www.unicode.org/reports/tr31/#NFKC_Modifications">https://www.unicode.org/reports/tr31/#NFKC_Modifications</a>)&gt; ID_Continue ::= ID_Start | &lt;characters having the Unicode General_Category of nonspacing marks, spacing combining marks, decimal number, connector punctuation, plus Other_ID_Continue, minus Pattern_Syntax and Pattern_White_Space code points&gt;</p>
<p>the currently implemented rule is this simpler one:</p>
<p>identifier ::= ID_Start id_continue* id_continue ::= ID_Start | decimal_number </p>

</div>
</div>
<a id="ae4ff448bb92e6499c0a76f7d8e11126c" name="ae4ff448bb92e6499c0a76f7d8e11126c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae4ff448bb92e6499c0a76f7d8e11126c">&#9670;&#160;</a></span>islower()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class CharT, class TraitsT, class AllocatorT&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const bool <a class="el" href="classpcs_1_1_cpp_string_t.html">pcs::CppStringT</a>&lt; CharT, TraitsT, AllocatorT &gt;::islower </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span><span class="mlabel nodiscard">nodiscard</span><span class="mlabel noexcept">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns true if all cased characters in the string are lowercase and there is at least one cased character, or false otherwise. </p>

</div>
</div>
<a id="a578176ed20fd8da965afbcae1d99dd59" name="a578176ed20fd8da965afbcae1d99dd59"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a578176ed20fd8da965afbcae1d99dd59">&#9670;&#160;</a></span>isnumeric()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class CharT, class TraitsT, class AllocatorT&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const bool <a class="el" href="classpcs_1_1_cpp_string_t.html">pcs::CppStringT</a>&lt; CharT, TraitsT, AllocatorT &gt;::isnumeric </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span><span class="mlabel nodiscard">nodiscard</span><span class="mlabel noexcept">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns true if all characters in the string are numeric characters, and there is at least one character, or false otherwise. </p>
<p>CAUTION: current implementation just returns <a class="el" href="#a0b9d8a55419274e7cfd9badb4df704e3" title="Returns true if all characters in the string are decimal characters and there is at least one charact...">isdecimal()</a> result, while the description of <a class="el" href="#a578176ed20fd8da965afbcae1d99dd59" title="Returns true if all characters in the string are numeric characters, and there is at least one charac...">isnumeric()</a> should be this one: Numeric characters include digit characters, and all characters that have the Unicode numeric value property. Formally, numeric characters are those with the property value Numeric_Type=Digit, Numeric_Type=Decimal or Numeric_Type=Numeric. </p>

</div>
</div>
<a id="a6257a1832da550d4be32e9f272e51265" name="a6257a1832da550d4be32e9f272e51265"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6257a1832da550d4be32e9f272e51265">&#9670;&#160;</a></span>isprintable()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class CharT, class TraitsT, class AllocatorT&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const bool <a class="el" href="classpcs_1_1_cpp_string_t.html">pcs::CppStringT</a>&lt; CharT, TraitsT, AllocatorT &gt;::isprintable </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span><span class="mlabel nodiscard">nodiscard</span><span class="mlabel noexcept">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns true if all characters in the string are printable or if the string is empty, or false otherwise. </p>
<p>Nonprintable characters are those characters defined in the Unicode character database as "Other" or "Separator", excepting the ASCII space (0x20) which is considered printable. </p>

</div>
</div>
<a id="a2842f3a067fdc674709bed048d64e12d" name="a2842f3a067fdc674709bed048d64e12d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2842f3a067fdc674709bed048d64e12d">&#9670;&#160;</a></span>ispunctuation()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class CharT, class TraitsT, class AllocatorT&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const bool <a class="el" href="classpcs_1_1_cpp_string_t.html">pcs::CppStringT</a>&lt; CharT, TraitsT, AllocatorT &gt;::ispunctuation </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span><span class="mlabel nodiscard">nodiscard</span><span class="mlabel noexcept">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns true if the string contains only one character and if this character belongs to the ASCII punctuation set. </p>

</div>
</div>
<a id="a959a8f56bb536f2474ffc649a7ad3290" name="a959a8f56bb536f2474ffc649a7ad3290"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a959a8f56bb536f2474ffc649a7ad3290">&#9670;&#160;</a></span>isspace()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class CharT, class TraitsT, class AllocatorT&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const bool <a class="el" href="classpcs_1_1_cpp_string_t.html">pcs::CppStringT</a>&lt; CharT, TraitsT, AllocatorT &gt;::isspace </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span><span class="mlabel nodiscard">nodiscard</span><span class="mlabel noexcept">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns true if there are only whitespace characters in the string and there is at least one character, or false otherwise. </p>

</div>
</div>
<a id="ad72611f339c2b9027a72fa26f25748c3" name="ad72611f339c2b9027a72fa26f25748c3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad72611f339c2b9027a72fa26f25748c3">&#9670;&#160;</a></span>istitle()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class CharT, class TraitsT, class AllocatorT&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const bool <a class="el" href="classpcs_1_1_cpp_string_t.html">pcs::CppStringT</a>&lt; CharT, TraitsT, AllocatorT &gt;::istitle </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span><span class="mlabel nodiscard">nodiscard</span><span class="mlabel noexcept">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns true if the string is a titlecased string and there is at least one character, or false otherwise. </p>
<p>For instance uppercase characters may only follow uncased characters and lowercase characters only cased ones.</p>
<p>CAUTION: current implementation only tests for uppercase characters following whitespaces and lowercase characters anywhere else. </p>

</div>
</div>
<a id="af2784cbe9655bb8e23fe90375d79e69c" name="af2784cbe9655bb8e23fe90375d79e69c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af2784cbe9655bb8e23fe90375d79e69c">&#9670;&#160;</a></span>isupper()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class CharT, class TraitsT, class AllocatorT&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const bool <a class="el" href="classpcs_1_1_cpp_string_t.html">pcs::CppStringT</a>&lt; CharT, TraitsT, AllocatorT &gt;::isupper </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span><span class="mlabel nodiscard">nodiscard</span><span class="mlabel noexcept">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns true if all cased characters in the string are uppercase and there is at least one cased character, or false otherwise. </p>

</div>
</div>
<a id="aa3523b858357399995e4fb9ec796c96c" name="aa3523b858357399995e4fb9ec796c96c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa3523b858357399995e4fb9ec796c96c">&#9670;&#160;</a></span>join() <span class="overload">[1/5]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class CharT, class TraitsT, class AllocatorT&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="classpcs_1_1_cpp_string_t.html">CppStringT</a> <a class="el" href="classpcs_1_1_cpp_string_t.html">pcs::CppStringT</a>&lt; CharT, TraitsT, AllocatorT &gt;::join </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span><span class="mlabel nodiscard">nodiscard</span><span class="mlabel noexcept">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Empty parameters list signature. Returns a copy of current string. </p>

<p class="reference">Referenced by <a class="el" href="#a545d669bb9296b5695b01ac8680bf3f4">pcs::CppStringT&lt; char &gt;::join()</a>.</p>

</div>
</div>
<a id="a545d669bb9296b5695b01ac8680bf3f4" name="a545d669bb9296b5695b01ac8680bf3f4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a545d669bb9296b5695b01ac8680bf3f4">&#9670;&#160;</a></span>join() <span class="overload">[2/5]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class CharT, class TraitsT, class AllocatorT&gt; </div>
<div class="memtemplate">
template&lt;class... NextCppStringsT&gt; <br />
requires (sizeof...(others) &gt; 0)</div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classpcs_1_1_cpp_string_t.html">CppStringT</a> <a class="el" href="classpcs_1_1_cpp_string_t.html">pcs::CppStringT</a>&lt; CharT, TraitsT, AllocatorT &gt;::join </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classpcs_1_1_cpp_string_t.html">CppStringT</a>&lt; CharT, TraitsT, AllocatorT &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>first</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const NextCppStringsT &amp;...</td>          <td class="paramname"><span class="paramname"><em>others</em></span>&#160;) const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span><span class="mlabel nodiscard">nodiscard</span><span class="mlabel noexcept">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns a string which is the concatenation of the strings in the parameters list. </p>
<p>The separator between elements is the string to which this method is applied. </p>

</div>
</div>
<a id="a30860a043574996d85c80e49ef618594" name="a30860a043574996d85c80e49ef618594"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a30860a043574996d85c80e49ef618594">&#9670;&#160;</a></span>join() <span class="overload">[3/5]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class CharT, class TraitsT, class AllocatorT&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classpcs_1_1_cpp_string_t.html">CppStringT</a> <a class="el" href="classpcs_1_1_cpp_string_t.html">pcs::CppStringT</a>&lt; CharT, TraitsT, AllocatorT &gt;::join </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classpcs_1_1_cpp_string_t.html">CppStringT</a>&lt; CharT, TraitsT, AllocatorT &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>s</em></span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span><span class="mlabel nodiscard">nodiscard</span><span class="mlabel noexcept">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Single parameter signature. Returns a copy of this parameter. </p>

</div>
</div>
<a id="ac1b427d4cc4c2aed8252b3526b63f1b1" name="ac1b427d4cc4c2aed8252b3526b63f1b1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac1b427d4cc4c2aed8252b3526b63f1b1">&#9670;&#160;</a></span>join() <span class="overload">[4/5]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class CharT, class TraitsT, class AllocatorT&gt; </div>
<div class="memtemplate">
template&lt;const std::size_t N&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classpcs_1_1_cpp_string_t.html">CppStringT</a> <a class="el" href="classpcs_1_1_cpp_string_t.html">pcs::CppStringT</a>&lt; CharT, TraitsT, AllocatorT &gt;::join </td>
          <td>(</td>
          <td class="paramtype">const std::array&lt; <a class="el" href="classpcs_1_1_cpp_string_t.html">CppStringT</a>&lt; CharT, TraitsT, AllocatorT &gt;, N &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>strs</em></span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span><span class="mlabel nodiscard">nodiscard</span><span class="mlabel noexcept">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns a string which is the concatenation of the strings in the array parameter. </p>
<p>The separator between elements is the string to which this method is applied. </p>

<p class="reference">Referenced by <a class="el" href="#a179634aafb049e8604ca78f813684a28">pcs::CppStringT&lt; char &gt;::title()</a>.</p>

</div>
</div>
<a id="a9eed3f6c5e09f98f3d5916cc5b3a4311" name="a9eed3f6c5e09f98f3d5916cc5b3a4311"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9eed3f6c5e09f98f3d5916cc5b3a4311">&#9670;&#160;</a></span>join() <span class="overload">[5/5]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class CharT, class TraitsT, class AllocatorT&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classpcs_1_1_cpp_string_t.html">CppStringT</a> <a class="el" href="classpcs_1_1_cpp_string_t.html">pcs::CppStringT</a>&lt; CharT, TraitsT, AllocatorT &gt;::join </td>
          <td>(</td>
          <td class="paramtype">const std::vector&lt; <a class="el" href="classpcs_1_1_cpp_string_t.html">CppStringT</a>&lt; CharT, TraitsT, AllocatorT &gt; &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>strs</em></span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span><span class="mlabel nodiscard">nodiscard</span><span class="mlabel noexcept">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns a string which is the concatenation of the strings in the vector parameter. </p>
<p>The separator between elements is the string to which this method is applied. </p>

</div>
</div>
<a id="aed96c44c384cab45342122cd7e2f02eb" name="aed96c44c384cab45342122cd7e2f02eb"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aed96c44c384cab45342122cd7e2f02eb">&#9670;&#160;</a></span>ljust()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class CharT, class TraitsT, class AllocatorT&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classpcs_1_1_cpp_string_t.html">CppStringT</a> <a class="el" href="classpcs_1_1_cpp_string_t.html">pcs::CppStringT</a>&lt; CharT, TraitsT, AllocatorT &gt;::ljust </td>
          <td>(</td>
          <td class="paramtype">const size_type</td>          <td class="paramname"><span class="paramname"><em>width</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const value_type</td>          <td class="paramname"><span class="paramname"><em>fillch</em></span><span class="paramdefsep"> = </span><span class="paramdefval">value_type('&#160;')</span>&#160;) const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span><span class="mlabel nodiscard">nodiscard</span><span class="mlabel noexcept">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns the string left justified in a string of length width. </p>
<p>Padding is done using the specified fillchar (default is an ASCII space). The original string is returned if width is less than or equal to len(s). </p>

<p class="reference">Referenced by <a class="el" href="#ad3d2b94f37325096205e399b95e9fc5d">pcs::CppStringT&lt; char &gt;::zfill()</a>.</p>

</div>
</div>
<a id="ad5c765eaa85cb4a3e7a914d55a6a5175" name="ad5c765eaa85cb4a3e7a914d55a6a5175"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad5c765eaa85cb4a3e7a914d55a6a5175">&#9670;&#160;</a></span>lower() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class CharT, class TraitsT, class AllocatorT&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classpcs_1_1_cpp_string_t.html">CppStringT</a> &amp; <a class="el" href="classpcs_1_1_cpp_string_t.html">pcs::CppStringT</a>&lt; CharT, TraitsT, AllocatorT &gt;::lower </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span><span class="mlabel noexcept">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>In-place replaces all characters of the string with their lowercase conversion. Returns a reference to string. </p>
<p>Notice: uses the currently set std::locale, which is the "C" one by default or any other one as previously set by the user. </p>

<p class="reference">Referenced by <a class="el" href="#a48a00cca031b9c29d1912508e120a5f6">pcs::CppStringT&lt; char &gt;::capitalize()</a>, and <a class="el" href="#ad5c765eaa85cb4a3e7a914d55a6a5175">pcs::CppStringT&lt; char &gt;::lower()</a>.</p>

</div>
</div>
<a id="a6b1cfc9713e55a48f036ed030bedc654" name="a6b1cfc9713e55a48f036ed030bedc654"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6b1cfc9713e55a48f036ed030bedc654">&#9670;&#160;</a></span>lower() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class CharT, class TraitsT, class AllocatorT&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const value_type <a class="el" href="classpcs_1_1_cpp_string_t.html">pcs::CppStringT</a>&lt; CharT, TraitsT, AllocatorT &gt;::lower </td>
          <td>(</td>
          <td class="paramtype">const value_type</td>          <td class="paramname"><span class="paramname"><em>ch</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span><span class="mlabel static">static</span><span class="mlabel nodiscard">nodiscard</span><span class="mlabel noexcept">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns lowercase conversion of the character. </p>
<p>Notice: uses the currently set std::locale, which is the "C" one by default or any other one as previously set by the user. </p>

</div>
</div>
<a id="ac1ad3018d38f291e6debad8d2de92be1" name="ac1ad3018d38f291e6debad8d2de92be1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac1ad3018d38f291e6debad8d2de92be1">&#9670;&#160;</a></span>lstrip() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class CharT, class TraitsT, class AllocatorT&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classpcs_1_1_cpp_string_t.html">CppStringT</a> <a class="el" href="classpcs_1_1_cpp_string_t.html">pcs::CppStringT</a>&lt; CharT, TraitsT, AllocatorT &gt;::lstrip </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span><span class="mlabel nodiscard">nodiscard</span><span class="mlabel noexcept">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns a copy of the string with leading whitespaces removed. </p>

</div>
</div>
<a id="aee6e48d5b478d5bab239f54523d23c15" name="aee6e48d5b478d5bab239f54523d23c15"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aee6e48d5b478d5bab239f54523d23c15">&#9670;&#160;</a></span>lstrip() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class CharT, class TraitsT, class AllocatorT&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classpcs_1_1_cpp_string_t.html">CppStringT</a> <a class="el" href="classpcs_1_1_cpp_string_t.html">pcs::CppStringT</a>&lt; CharT, TraitsT, AllocatorT &gt;::lstrip </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classpcs_1_1_cpp_string_t.html">CppStringT</a>&lt; CharT, TraitsT, AllocatorT &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>removedchars</em></span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span><span class="mlabel nodiscard">nodiscard</span><span class="mlabel noexcept">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns a copy of the string with leading characters removed. </p>
<p>The passed string specifies the set of characters to be removed. The chars argument is not a prefix; rather, all combinations of its values are stripped. To remove a prefix, rather call method '<a class="el" href="#a058704b7f4538ec9e1798c5348d37c7a" title="If the string starts with the prefix string, returns a new string with the prefix removed....">removeprefix()</a>'. </p>

<p class="reference">Referenced by <a class="el" href="#a12bc043347f555b4701e0c70d972058d">pcs::CppStringT&lt; char &gt;::strip()</a>, and <a class="el" href="#a02919129cdf158e75eae1e9815a071bf">pcs::CppStringT&lt; char &gt;::strip()</a>.</p>

</div>
</div>
<a id="a0daec57ccab4601f46e9d1c258407765" name="a0daec57ccab4601f46e9d1c258407765"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0daec57ccab4601f46e9d1c258407765">&#9670;&#160;</a></span>operator()() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class CharT, class TraitsT, class AllocatorT&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classpcs_1_1_cpp_string_t.html">CppStringT</a> <a class="el" href="classpcs_1_1_cpp_string_t.html">pcs::CppStringT</a>&lt; CharT, TraitsT, AllocatorT &gt;::operator() </td>
          <td>(</td>
          <td class="paramtype">const long long</td>          <td class="paramname"><span class="paramname"><em>start</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const long long</td>          <td class="paramname"><span class="paramname"><em>stop</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const long long</td>          <td class="paramname"><span class="paramname"><em>step</em></span><span class="paramdefsep"> = </span><span class="paramdefval">1</span>&#160;) const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span><span class="mlabel nodiscard">nodiscard</span><span class="mlabel noexcept">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Generates a new string according to the specified slicing values. </p>

</div>
</div>
<a id="a1fa8862a5f306553d6f0dae7e76fce83" name="a1fa8862a5f306553d6f0dae7e76fce83"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1fa8862a5f306553d6f0dae7e76fce83">&#9670;&#160;</a></span>operator()() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class CharT, class TraitsT, class AllocatorT&gt; </div>
<div class="memtemplate">
template&lt;typename IntT&gt; <br />
requires std::is_signed_v&lt;IntT&gt;</div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classpcs_1_1_cpp_string_t.html">CppStringT</a> <a class="el" href="classpcs_1_1_cpp_string_t.html">pcs::CppStringT</a>&lt; CharT, TraitsT, AllocatorT &gt;::operator() </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classpcs_1_1_slice.html">Slice</a>&lt; IntT &gt;</td>          <td class="paramname"><span class="paramname"><em>slice</em></span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span><span class="mlabel nodiscard">nodiscard</span><span class="mlabel noexcept">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Generates a new string according to the specified slice. </p>
<p>A slice is a range specified as [start, stop, step]. It may also be specified as [start, stop] in which case step = 1, or as [stop] in wich case start = 0 and step = 1. Values may be negative: negative step means reverse running and negative start or stop is relative to the end of the string. Notice: the stop value specifies an out of bounds index. </p><dl class="section see"><dt>See also</dt><dd>class <a class="el" href="classpcs_1_1_slice.html" title="Base class for slices, with start, stop and step specified values.">Slice</a> and all its inheriting classes. </dd></dl>

</div>
</div>
<a id="a0995f5b5a01af3f4a749949e23d0d780" name="a0995f5b5a01af3f4a749949e23d0d780"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0995f5b5a01af3f4a749949e23d0d780">&#9670;&#160;</a></span>operator*()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class CharT, class TraitsT, class AllocatorT&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classpcs_1_1_cpp_string_t.html">CppStringT</a> <a class="el" href="classpcs_1_1_cpp_string_t.html">pcs::CppStringT</a>&lt; CharT, TraitsT, AllocatorT &gt;::operator* </td>
          <td>(</td>
          <td class="paramtype">std::int64_t</td>          <td class="paramname"><span class="paramname"><em>count</em></span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span><span class="mlabel nodiscard">nodiscard</span><span class="mlabel noexcept">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Generates a new string with count times the content of this string. </p>

</div>
</div>
<a id="a30e26a3082ad50d01c7d0d98cb9e9c37" name="a30e26a3082ad50d01c7d0d98cb9e9c37"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a30e26a3082ad50d01c7d0d98cb9e9c37">&#9670;&#160;</a></span>operator=() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class CharT, class TraitsT, class AllocatorT&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classpcs_1_1_cpp_string_t.html">CppStringT</a> &amp; <a class="el" href="classpcs_1_1_cpp_string_t.html">pcs::CppStringT</a>&lt; CharT, TraitsT, AllocatorT &gt;::operator= </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classpcs_1_1_cpp_string_t.html">CppStringT</a>&lt; CharT, TraitsT, AllocatorT &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel default">default</span><span class="mlabel noexcept">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Default copy assignment. </p>

</div>
</div>
<a id="a810a3a27ee7396f9c472648978327a76" name="a810a3a27ee7396f9c472648978327a76"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a810a3a27ee7396f9c472648978327a76">&#9670;&#160;</a></span>operator=() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class CharT, class TraitsT, class AllocatorT&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classpcs_1_1_cpp_string_t.html">CppStringT</a> &amp; <a class="el" href="classpcs_1_1_cpp_string_t.html">pcs::CppStringT</a>&lt; CharT, TraitsT, AllocatorT &gt;::operator= </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classpcs_1_1_cpp_string_t.html">CppStringT</a>&lt; CharT, TraitsT, AllocatorT &gt; &amp;&amp;</td>          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel default">default</span><span class="mlabel noexcept">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Default move assignment. </p>

</div>
</div>
<a id="ac5f88b0fc1f33cda23c30cb1f3bc560f" name="ac5f88b0fc1f33cda23c30cb1f3bc560f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac5f88b0fc1f33cda23c30cb1f3bc560f">&#9670;&#160;</a></span>partition()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class CharT, class TraitsT, class AllocatorT&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::vector&lt; <a class="el" href="classpcs_1_1_cpp_string_t.html">CppStringT</a> &gt; <a class="el" href="classpcs_1_1_cpp_string_t.html">pcs::CppStringT</a>&lt; CharT, TraitsT, AllocatorT &gt;::partition </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classpcs_1_1_cpp_string_t.html">CppStringT</a>&lt; CharT, TraitsT, AllocatorT &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>sep</em></span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span><span class="mlabel nodiscard">nodiscard</span><span class="mlabel noexcept">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Splits the string at the first occurrence of sep, and returns a 3-items vector containing the part before the separator, the separator itself, and the part after the separator. </p>
<p>If the separator is not found, returns a 3-items vector containing the string itself, followed by two empty strings. </p>

</div>
</div>
<a id="a058704b7f4538ec9e1798c5348d37c7a" name="a058704b7f4538ec9e1798c5348d37c7a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a058704b7f4538ec9e1798c5348d37c7a">&#9670;&#160;</a></span>removeprefix()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class CharT, class TraitsT, class AllocatorT&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classpcs_1_1_cpp_string_t.html">CppStringT</a> <a class="el" href="classpcs_1_1_cpp_string_t.html">pcs::CppStringT</a>&lt; CharT, TraitsT, AllocatorT &gt;::removeprefix </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classpcs_1_1_cpp_string_t.html">CppStringT</a>&lt; CharT, TraitsT, AllocatorT &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>prefix</em></span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span><span class="mlabel nodiscard">nodiscard</span><span class="mlabel noexcept">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>If the string starts with the prefix string, returns a new string with the prefix removed. Otherwise, returns a copy of the original string. </p>

</div>
</div>
<a id="ad6a8dc124ab8b7cab1cb328240763ed0" name="ad6a8dc124ab8b7cab1cb328240763ed0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad6a8dc124ab8b7cab1cb328240763ed0">&#9670;&#160;</a></span>removesuffix()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class CharT, class TraitsT, class AllocatorT&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classpcs_1_1_cpp_string_t.html">CppStringT</a> <a class="el" href="classpcs_1_1_cpp_string_t.html">pcs::CppStringT</a>&lt; CharT, TraitsT, AllocatorT &gt;::removesuffix </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classpcs_1_1_cpp_string_t.html">CppStringT</a>&lt; CharT, TraitsT, AllocatorT &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>suffix</em></span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span><span class="mlabel nodiscard">nodiscard</span><span class="mlabel noexcept">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>If the string ends with the suffix string, returns a new string with the suffix removed. Otherwise, returns a copy of the original string. </p>

</div>
</div>
<a id="ad4f39683db649aa8a65907268c499f02" name="ad4f39683db649aa8a65907268c499f02"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad4f39683db649aa8a65907268c499f02">&#9670;&#160;</a></span>replace()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class CharT, class TraitsT, class AllocatorT&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classpcs_1_1_cpp_string_t.html">CppStringT</a> <a class="el" href="classpcs_1_1_cpp_string_t.html">pcs::CppStringT</a>&lt; CharT, TraitsT, AllocatorT &gt;::replace </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classpcs_1_1_cpp_string_t.html">CppStringT</a>&lt; CharT, TraitsT, AllocatorT &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>old</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classpcs_1_1_cpp_string_t.html">CppStringT</a>&lt; CharT, TraitsT, AllocatorT &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>new_</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_type</td>          <td class="paramname"><span class="paramname"><em>count</em></span><span class="paramdefsep"> = </span><span class="paramdefval">-1</span>&#160;) const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span><span class="mlabel nodiscard">nodiscard</span><span class="mlabel noexcept">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns a copy of the string with first count occurrences of substring 'old' replaced by 'new_'. </p>

</div>
</div>
<a id="ac00bb6f7d74bfdde0d4cc247e78ab20e" name="ac00bb6f7d74bfdde0d4cc247e78ab20e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac00bb6f7d74bfdde0d4cc247e78ab20e">&#9670;&#160;</a></span>rfind() <span class="overload">[1/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class CharT, class TraitsT, class AllocatorT&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">size_type <a class="el" href="classpcs_1_1_cpp_string_t.html">pcs::CppStringT</a>&lt; CharT, TraitsT, AllocatorT &gt;::rfind </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classpcs_1_1_cpp_string_t.html">CppStringT</a>&lt; CharT, TraitsT, AllocatorT &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>sub</em></span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span><span class="mlabel nodiscard">nodiscard</span><span class="mlabel constexpr">constexpr</span><span class="mlabel noexcept">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns the highest index in the string where C-substring sub is found in the whole string, or -1 (i.e. 'npos') if sub is not found. </p>
<p>Note that this is an offset from the start of the string, not the end.</p>
<p>Note: this method should be used only if you need to know the position of sub. To check if sub is a substring or not, use the method <a class="el" href="#a0674e29327353aabf83d0e207fed31ed" title="Returns true if this string contains the passed string, or false otherwise.">contains()</a>.</p>
<p>CAUTION: empty substrings are considered to be in the string if start and end positions are both less than the string size and if start &lt;= end. The returned position is the size of the string.</p>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="#a24c4b7a0f713373cb3287d92289562ad" title="Returns the lowest index in the string where substring sub is found within the slice str[start:end],...">find()</a>, <a class="el" href="#ac4c9351bb52eb9a62fa7fb2e2d5f054d" title="Returns the lowest index in the string where substring sub is found within the slice str[start:start+...">find_n()</a> and <a class="el" href="#a519a292eb3f0790d54a59a201f2d6410" title="Returns the highest index in the string where substring sub is found within the slice str[start:start...">rfind_n()</a>. </dd>
<dd>
<a class="el" href="#a277a2b8a3b93951ccb94b6bf39daa582" title="Like find(const CppStringT&amp;), but raises NotFoundException when the substring sub is not found.">index()</a>, <a class="el" href="#aee94d4b52483021051b168e776b18569" title="Like find_n(sub, start, count), but raises NotFoundException when the substring is not found.">index_n()</a>, <a class="el" href="#a6693ec49258c6ac80a7875b3ebf3c916" title="Like rfind(sub, start, end), but raises NotFoundException when the substring is not found.">rindex()</a> and <a class="el" href="#afc08a4e91b93710838c8f0d6234e057e" title="Like rfind_n(sub, start, count), but raises NotFoundException when the substring is not found.">rindex_n()</a>. </dd></dl>

</div>
</div>
<a id="a9f43f20029596abc1362d1242e68e5db" name="a9f43f20029596abc1362d1242e68e5db"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9f43f20029596abc1362d1242e68e5db">&#9670;&#160;</a></span>rfind() <span class="overload">[2/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class CharT, class TraitsT, class AllocatorT&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">size_type <a class="el" href="classpcs_1_1_cpp_string_t.html">pcs::CppStringT</a>&lt; CharT, TraitsT, AllocatorT &gt;::rfind </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classpcs_1_1_cpp_string_t.html">CppStringT</a>&lt; CharT, TraitsT, AllocatorT &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>sub</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const size_type</td>          <td class="paramname"><span class="paramname"><em>start</em></span>&#160;) const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span><span class="mlabel nodiscard">nodiscard</span><span class="mlabel constexpr">constexpr</span><span class="mlabel noexcept">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns the highest index in the string where substring sub is found starting at start position in string, or -1 (i.e. 'npos') if sub is not found. </p>
<p>Note that this is an offset from the start of the string, not the end.</p>
<p>Note: this method should be used only if you need to know the position of sub. To check if sub is a substring or not, use the method <a class="el" href="#a0674e29327353aabf83d0e207fed31ed" title="Returns true if this string contains the passed string, or false otherwise.">contains()</a>.</p>
<p>CAUTION: empty substrings are considered to be in the string if start and end positions are both less than the string size and if start &lt;= end. The returned position is the size of the string.</p>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="#a24c4b7a0f713373cb3287d92289562ad" title="Returns the lowest index in the string where substring sub is found within the slice str[start:end],...">find()</a>, <a class="el" href="#ac4c9351bb52eb9a62fa7fb2e2d5f054d" title="Returns the lowest index in the string where substring sub is found within the slice str[start:start+...">find_n()</a> and <a class="el" href="#a519a292eb3f0790d54a59a201f2d6410" title="Returns the highest index in the string where substring sub is found within the slice str[start:start...">rfind_n()</a>. </dd>
<dd>
<a class="el" href="#a277a2b8a3b93951ccb94b6bf39daa582" title="Like find(const CppStringT&amp;), but raises NotFoundException when the substring sub is not found.">index()</a>, <a class="el" href="#aee94d4b52483021051b168e776b18569" title="Like find_n(sub, start, count), but raises NotFoundException when the substring is not found.">index_n()</a>, <a class="el" href="#a6693ec49258c6ac80a7875b3ebf3c916" title="Like rfind(sub, start, end), but raises NotFoundException when the substring is not found.">rindex()</a> and <a class="el" href="#afc08a4e91b93710838c8f0d6234e057e" title="Like rfind_n(sub, start, count), but raises NotFoundException when the substring is not found.">rindex_n()</a>. </dd></dl>

</div>
</div>
<a id="af363308ba741b267641e1aa35669d603" name="af363308ba741b267641e1aa35669d603"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af363308ba741b267641e1aa35669d603">&#9670;&#160;</a></span>rfind() <span class="overload">[3/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class CharT, class TraitsT, class AllocatorT&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">size_type <a class="el" href="classpcs_1_1_cpp_string_t.html">pcs::CppStringT</a>&lt; CharT, TraitsT, AllocatorT &gt;::rfind </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classpcs_1_1_cpp_string_t.html">CppStringT</a>&lt; CharT, TraitsT, AllocatorT &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>sub</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const size_type</td>          <td class="paramname"><span class="paramname"><em>start</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const size_type</td>          <td class="paramname"><span class="paramname"><em>end</em></span>&#160;) const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span><span class="mlabel nodiscard">nodiscard</span><span class="mlabel constexpr">constexpr</span><span class="mlabel noexcept">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns the highest index in the string where substring sub is found within the slice str[start:end], or -1 (i.e. 'npos') if sub is not found. </p>
<p>Note that this is an offset from the start of the string, not the end.</p>
<p>Note: this method should be used only if you need to know the position of sub. To check if sub is a substring or not, use the method <a class="el" href="#a0674e29327353aabf83d0e207fed31ed" title="Returns true if this string contains the passed string, or false otherwise.">contains()</a>.</p>
<p>CAUTION: empty substrings are considered to be in the string if start and end positions are both less than the string size and if start &lt;= end. The returned position is the size of the string.</p>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="#a24c4b7a0f713373cb3287d92289562ad" title="Returns the lowest index in the string where substring sub is found within the slice str[start:end],...">find()</a>, <a class="el" href="#ac4c9351bb52eb9a62fa7fb2e2d5f054d" title="Returns the lowest index in the string where substring sub is found within the slice str[start:start+...">find_n()</a> and <a class="el" href="#a519a292eb3f0790d54a59a201f2d6410" title="Returns the highest index in the string where substring sub is found within the slice str[start:start...">rfind_n()</a>. </dd>
<dd>
<a class="el" href="#a277a2b8a3b93951ccb94b6bf39daa582" title="Like find(const CppStringT&amp;), but raises NotFoundException when the substring sub is not found.">index()</a>, <a class="el" href="#aee94d4b52483021051b168e776b18569" title="Like find_n(sub, start, count), but raises NotFoundException when the substring is not found.">index_n()</a>, <a class="el" href="#a6693ec49258c6ac80a7875b3ebf3c916" title="Like rfind(sub, start, end), but raises NotFoundException when the substring is not found.">rindex()</a> and <a class="el" href="#afc08a4e91b93710838c8f0d6234e057e" title="Like rfind_n(sub, start, count), but raises NotFoundException when the substring is not found.">rindex_n()</a>. </dd></dl>

<p class="reference">Referenced by <a class="el" href="#a9f43f20029596abc1362d1242e68e5db">pcs::CppStringT&lt; char &gt;::rfind()</a>, <a class="el" href="#af363308ba741b267641e1aa35669d603">pcs::CppStringT&lt; char &gt;::rfind()</a>, <a class="el" href="#a790f663f51dfe6e9e15d4f5f025bf107">pcs::CppStringT&lt; char &gt;::rfind_n()</a>, <a class="el" href="#a519a292eb3f0790d54a59a201f2d6410">pcs::CppStringT&lt; char &gt;::rfind_n()</a>, <a class="el" href="#a6693ec49258c6ac80a7875b3ebf3c916">pcs::CppStringT&lt; char &gt;::rindex()</a>, <a class="el" href="#a61674ee4e97038d82ea7ecc30b1761f6">pcs::CppStringT&lt; char &gt;::rpartition()</a>, and <a class="el" href="#ab0ace502f0b3026fefd2942a1e8a0456">pcs::CppStringT&lt; char &gt;::rsplit()</a>.</p>

</div>
</div>
<a id="a790f663f51dfe6e9e15d4f5f025bf107" name="a790f663f51dfe6e9e15d4f5f025bf107"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a790f663f51dfe6e9e15d4f5f025bf107">&#9670;&#160;</a></span>rfind_n() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class CharT, class TraitsT, class AllocatorT&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">size_type <a class="el" href="classpcs_1_1_cpp_string_t.html">pcs::CppStringT</a>&lt; CharT, TraitsT, AllocatorT &gt;::rfind_n </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classpcs_1_1_cpp_string_t.html">CppStringT</a>&lt; CharT, TraitsT, AllocatorT &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>sub</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const size_type</td>          <td class="paramname"><span class="paramname"><em>count</em></span>&#160;) const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span><span class="mlabel nodiscard">nodiscard</span><span class="mlabel constexpr">constexpr</span><span class="mlabel noexcept">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns the highest index in the string where substring sub is found within the slice str[0:count-1], or -1 (i.e. 'npos') if sub is not found. </p>
<p>Note: this method should be used only if you need to know the position of sub. To check if sub is a substring or not, use the method <a class="el" href="#a031b05f290f589b2df52bb84252c27c7" title="Returns true if the passed string is found within the slice str[start:start+count-1],...">contains_n()</a>.</p>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="#a24c4b7a0f713373cb3287d92289562ad" title="Returns the lowest index in the string where substring sub is found within the slice str[start:end],...">find()</a>, <a class="el" href="#ac4c9351bb52eb9a62fa7fb2e2d5f054d" title="Returns the lowest index in the string where substring sub is found within the slice str[start:start+...">find_n()</a> and <a class="el" href="#af363308ba741b267641e1aa35669d603" title="Returns the highest index in the string where substring sub is found within the slice str[start:end],...">rfind()</a>. </dd>
<dd>
<a class="el" href="#a277a2b8a3b93951ccb94b6bf39daa582" title="Like find(const CppStringT&amp;), but raises NotFoundException when the substring sub is not found.">index()</a>, <a class="el" href="#aee94d4b52483021051b168e776b18569" title="Like find_n(sub, start, count), but raises NotFoundException when the substring is not found.">index_n()</a>, <a class="el" href="#a6693ec49258c6ac80a7875b3ebf3c916" title="Like rfind(sub, start, end), but raises NotFoundException when the substring is not found.">rindex()</a> and <a class="el" href="#afc08a4e91b93710838c8f0d6234e057e" title="Like rfind_n(sub, start, count), but raises NotFoundException when the substring is not found.">rindex_n()</a>. </dd></dl>

</div>
</div>
<a id="a519a292eb3f0790d54a59a201f2d6410" name="a519a292eb3f0790d54a59a201f2d6410"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a519a292eb3f0790d54a59a201f2d6410">&#9670;&#160;</a></span>rfind_n() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class CharT, class TraitsT, class AllocatorT&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">size_type <a class="el" href="classpcs_1_1_cpp_string_t.html">pcs::CppStringT</a>&lt; CharT, TraitsT, AllocatorT &gt;::rfind_n </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classpcs_1_1_cpp_string_t.html">CppStringT</a>&lt; CharT, TraitsT, AllocatorT &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>sub</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const size_type</td>          <td class="paramname"><span class="paramname"><em>start</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const size_type</td>          <td class="paramname"><span class="paramname"><em>count</em></span>&#160;) const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span><span class="mlabel nodiscard">nodiscard</span><span class="mlabel constexpr">constexpr</span><span class="mlabel noexcept">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns the highest index in the string where substring sub is found within the slice str[start:start+count-1], or -1 (i.e. 'npos') if sub is not found. </p>
<p>Note: this method should be used only if you need to know the position of sub. To check if sub is a substring or not, use the method <a class="el" href="#a031b05f290f589b2df52bb84252c27c7" title="Returns true if the passed string is found within the slice str[start:start+count-1],...">contains_n()</a>.</p>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="#a24c4b7a0f713373cb3287d92289562ad" title="Returns the lowest index in the string where substring sub is found within the slice str[start:end],...">find()</a>, <a class="el" href="#ac4c9351bb52eb9a62fa7fb2e2d5f054d" title="Returns the lowest index in the string where substring sub is found within the slice str[start:start+...">find_n()</a> and <a class="el" href="#af363308ba741b267641e1aa35669d603" title="Returns the highest index in the string where substring sub is found within the slice str[start:end],...">rfind()</a>. </dd>
<dd>
<a class="el" href="#a277a2b8a3b93951ccb94b6bf39daa582" title="Like find(const CppStringT&amp;), but raises NotFoundException when the substring sub is not found.">index()</a>, <a class="el" href="#aee94d4b52483021051b168e776b18569" title="Like find_n(sub, start, count), but raises NotFoundException when the substring is not found.">index_n()</a>, <a class="el" href="#a6693ec49258c6ac80a7875b3ebf3c916" title="Like rfind(sub, start, end), but raises NotFoundException when the substring is not found.">rindex()</a> and <a class="el" href="#afc08a4e91b93710838c8f0d6234e057e" title="Like rfind_n(sub, start, count), but raises NotFoundException when the substring is not found.">rindex_n()</a>. </dd></dl>

</div>
</div>
<a id="a546105cc9a8a9d493979c30607092cf1" name="a546105cc9a8a9d493979c30607092cf1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a546105cc9a8a9d493979c30607092cf1">&#9670;&#160;</a></span>rindex() <span class="overload">[1/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class CharT, class TraitsT, class AllocatorT&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">size_type <a class="el" href="classpcs_1_1_cpp_string_t.html">pcs::CppStringT</a>&lt; CharT, TraitsT, AllocatorT &gt;::rindex </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classpcs_1_1_cpp_string_t.html">CppStringT</a>&lt; CharT, TraitsT, AllocatorT &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>sub</em></span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span><span class="mlabel nodiscard">nodiscard</span><span class="mlabel constexpr">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Like rfind(sub), but raises <a class="el" href="classpcs_1_1_cpp_string_t_1_1_not_found_exception.html">NotFoundException</a> when the substring is not found. </p>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="#a277a2b8a3b93951ccb94b6bf39daa582" title="Like find(const CppStringT&amp;), but raises NotFoundException when the substring sub is not found.">index()</a>, <a class="el" href="#aee94d4b52483021051b168e776b18569" title="Like find_n(sub, start, count), but raises NotFoundException when the substring is not found.">index_n()</a> and <a class="el" href="#afc08a4e91b93710838c8f0d6234e057e" title="Like rfind_n(sub, start, count), but raises NotFoundException when the substring is not found.">rindex_n()</a>. </dd>
<dd>
<a class="el" href="#a24c4b7a0f713373cb3287d92289562ad" title="Returns the lowest index in the string where substring sub is found within the slice str[start:end],...">find()</a>, <a class="el" href="#ac4c9351bb52eb9a62fa7fb2e2d5f054d" title="Returns the lowest index in the string where substring sub is found within the slice str[start:start+...">find_n()</a>, <a class="el" href="#af363308ba741b267641e1aa35669d603" title="Returns the highest index in the string where substring sub is found within the slice str[start:end],...">rfind()</a> and <a class="el" href="#a519a292eb3f0790d54a59a201f2d6410" title="Returns the highest index in the string where substring sub is found within the slice str[start:start...">rfind_n()</a>. </dd></dl>

</div>
</div>
<a id="a2baca0ddff848de56a7b867f68d3efab" name="a2baca0ddff848de56a7b867f68d3efab"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2baca0ddff848de56a7b867f68d3efab">&#9670;&#160;</a></span>rindex() <span class="overload">[2/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class CharT, class TraitsT, class AllocatorT&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">size_type <a class="el" href="classpcs_1_1_cpp_string_t.html">pcs::CppStringT</a>&lt; CharT, TraitsT, AllocatorT &gt;::rindex </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classpcs_1_1_cpp_string_t.html">CppStringT</a>&lt; CharT, TraitsT, AllocatorT &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>sub</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const size_type</td>          <td class="paramname"><span class="paramname"><em>start</em></span>&#160;) const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span><span class="mlabel nodiscard">nodiscard</span><span class="mlabel constexpr">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Like rfind(sub, start), but raises <a class="el" href="classpcs_1_1_cpp_string_t_1_1_not_found_exception.html">NotFoundException</a> when the substring is not found. </p>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="#a277a2b8a3b93951ccb94b6bf39daa582" title="Like find(const CppStringT&amp;), but raises NotFoundException when the substring sub is not found.">index()</a>, <a class="el" href="#aee94d4b52483021051b168e776b18569" title="Like find_n(sub, start, count), but raises NotFoundException when the substring is not found.">index_n()</a> and <a class="el" href="#afc08a4e91b93710838c8f0d6234e057e" title="Like rfind_n(sub, start, count), but raises NotFoundException when the substring is not found.">rindex_n()</a>. </dd>
<dd>
<a class="el" href="#a24c4b7a0f713373cb3287d92289562ad" title="Returns the lowest index in the string where substring sub is found within the slice str[start:end],...">find()</a>, <a class="el" href="#ac4c9351bb52eb9a62fa7fb2e2d5f054d" title="Returns the lowest index in the string where substring sub is found within the slice str[start:start+...">find_n()</a>, <a class="el" href="#af363308ba741b267641e1aa35669d603" title="Returns the highest index in the string where substring sub is found within the slice str[start:end],...">rfind()</a> and <a class="el" href="#a519a292eb3f0790d54a59a201f2d6410" title="Returns the highest index in the string where substring sub is found within the slice str[start:start...">rfind_n()</a>. </dd></dl>

</div>
</div>
<a id="a6693ec49258c6ac80a7875b3ebf3c916" name="a6693ec49258c6ac80a7875b3ebf3c916"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6693ec49258c6ac80a7875b3ebf3c916">&#9670;&#160;</a></span>rindex() <span class="overload">[3/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class CharT, class TraitsT, class AllocatorT&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">size_type <a class="el" href="classpcs_1_1_cpp_string_t.html">pcs::CppStringT</a>&lt; CharT, TraitsT, AllocatorT &gt;::rindex </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classpcs_1_1_cpp_string_t.html">CppStringT</a>&lt; CharT, TraitsT, AllocatorT &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>sub</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const size_type</td>          <td class="paramname"><span class="paramname"><em>start</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const size_type</td>          <td class="paramname"><span class="paramname"><em>end</em></span>&#160;) const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span><span class="mlabel nodiscard">nodiscard</span><span class="mlabel constexpr">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Like rfind(sub, start, end), but raises <a class="el" href="classpcs_1_1_cpp_string_t_1_1_not_found_exception.html">NotFoundException</a> when the substring is not found. </p>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="#a277a2b8a3b93951ccb94b6bf39daa582" title="Like find(const CppStringT&amp;), but raises NotFoundException when the substring sub is not found.">index()</a>, <a class="el" href="#aee94d4b52483021051b168e776b18569" title="Like find_n(sub, start, count), but raises NotFoundException when the substring is not found.">index_n()</a> and <a class="el" href="#afc08a4e91b93710838c8f0d6234e057e" title="Like rfind_n(sub, start, count), but raises NotFoundException when the substring is not found.">rindex_n()</a>. </dd>
<dd>
<a class="el" href="#a24c4b7a0f713373cb3287d92289562ad" title="Returns the lowest index in the string where substring sub is found within the slice str[start:end],...">find()</a>, <a class="el" href="#ac4c9351bb52eb9a62fa7fb2e2d5f054d" title="Returns the lowest index in the string where substring sub is found within the slice str[start:start+...">find_n()</a>, <a class="el" href="#af363308ba741b267641e1aa35669d603" title="Returns the highest index in the string where substring sub is found within the slice str[start:end],...">rfind()</a> and <a class="el" href="#a519a292eb3f0790d54a59a201f2d6410" title="Returns the highest index in the string where substring sub is found within the slice str[start:start...">rfind_n()</a>. </dd></dl>

<p class="reference">Referenced by <a class="el" href="#a546105cc9a8a9d493979c30607092cf1">pcs::CppStringT&lt; char &gt;::rindex()</a>, <a class="el" href="#a2baca0ddff848de56a7b867f68d3efab">pcs::CppStringT&lt; char &gt;::rindex()</a>, <a class="el" href="#ac3079cbecbdf4151e66f602f39ece836">pcs::CppStringT&lt; char &gt;::rindex_n()</a>, and <a class="el" href="#afc08a4e91b93710838c8f0d6234e057e">pcs::CppStringT&lt; char &gt;::rindex_n()</a>.</p>

</div>
</div>
<a id="ac3079cbecbdf4151e66f602f39ece836" name="ac3079cbecbdf4151e66f602f39ece836"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac3079cbecbdf4151e66f602f39ece836">&#9670;&#160;</a></span>rindex_n() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class CharT, class TraitsT, class AllocatorT&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">size_type <a class="el" href="classpcs_1_1_cpp_string_t.html">pcs::CppStringT</a>&lt; CharT, TraitsT, AllocatorT &gt;::rindex_n </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classpcs_1_1_cpp_string_t.html">CppStringT</a>&lt; CharT, TraitsT, AllocatorT &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>sub</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const size_type</td>          <td class="paramname"><span class="paramname"><em>count</em></span>&#160;) const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span><span class="mlabel nodiscard">nodiscard</span><span class="mlabel constexpr">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Like rfind_n(sub, count), but raises <a class="el" href="classpcs_1_1_cpp_string_t_1_1_not_found_exception.html">NotFoundException</a> when the substring is not found. </p>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="#aee94d4b52483021051b168e776b18569" title="Like find_n(sub, start, count), but raises NotFoundException when the substring is not found.">index_n()</a>, <a class="el" href="#a6693ec49258c6ac80a7875b3ebf3c916" title="Like rfind(sub, start, end), but raises NotFoundException when the substring is not found.">rindex()</a> and <a class="el" href="#afc08a4e91b93710838c8f0d6234e057e" title="Like rfind_n(sub, start, count), but raises NotFoundException when the substring is not found.">rindex_n()</a>. </dd>
<dd>
<a class="el" href="#a24c4b7a0f713373cb3287d92289562ad" title="Returns the lowest index in the string where substring sub is found within the slice str[start:end],...">find()</a>, <a class="el" href="#ac4c9351bb52eb9a62fa7fb2e2d5f054d" title="Returns the lowest index in the string where substring sub is found within the slice str[start:start+...">find_n()</a>, <a class="el" href="#af363308ba741b267641e1aa35669d603" title="Returns the highest index in the string where substring sub is found within the slice str[start:end],...">rfind()</a> and <a class="el" href="#a519a292eb3f0790d54a59a201f2d6410" title="Returns the highest index in the string where substring sub is found within the slice str[start:start...">rfind_n()</a>. </dd></dl>

</div>
</div>
<a id="afc08a4e91b93710838c8f0d6234e057e" name="afc08a4e91b93710838c8f0d6234e057e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#afc08a4e91b93710838c8f0d6234e057e">&#9670;&#160;</a></span>rindex_n() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class CharT, class TraitsT, class AllocatorT&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">size_type <a class="el" href="classpcs_1_1_cpp_string_t.html">pcs::CppStringT</a>&lt; CharT, TraitsT, AllocatorT &gt;::rindex_n </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classpcs_1_1_cpp_string_t.html">CppStringT</a>&lt; CharT, TraitsT, AllocatorT &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>sub</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const size_type</td>          <td class="paramname"><span class="paramname"><em>start</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const size_type</td>          <td class="paramname"><span class="paramname"><em>count</em></span>&#160;) const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span><span class="mlabel nodiscard">nodiscard</span><span class="mlabel constexpr">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Like rfind_n(sub, start, count), but raises <a class="el" href="classpcs_1_1_cpp_string_t_1_1_not_found_exception.html">NotFoundException</a> when the substring is not found. </p>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="#aee94d4b52483021051b168e776b18569" title="Like find_n(sub, start, count), but raises NotFoundException when the substring is not found.">index_n()</a>, <a class="el" href="#a6693ec49258c6ac80a7875b3ebf3c916" title="Like rfind(sub, start, end), but raises NotFoundException when the substring is not found.">rindex()</a> and <a class="el" href="#afc08a4e91b93710838c8f0d6234e057e" title="Like rfind_n(sub, start, count), but raises NotFoundException when the substring is not found.">rindex_n()</a>. </dd>
<dd>
<a class="el" href="#a24c4b7a0f713373cb3287d92289562ad" title="Returns the lowest index in the string where substring sub is found within the slice str[start:end],...">find()</a>, <a class="el" href="#ac4c9351bb52eb9a62fa7fb2e2d5f054d" title="Returns the lowest index in the string where substring sub is found within the slice str[start:start+...">find_n()</a>, <a class="el" href="#af363308ba741b267641e1aa35669d603" title="Returns the highest index in the string where substring sub is found within the slice str[start:end],...">rfind()</a> and <a class="el" href="#a519a292eb3f0790d54a59a201f2d6410" title="Returns the highest index in the string where substring sub is found within the slice str[start:start...">rfind_n()</a>. </dd></dl>

</div>
</div>
<a id="a61fd4215938ec9f0fce1f885d6bb4a2b" name="a61fd4215938ec9f0fce1f885d6bb4a2b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a61fd4215938ec9f0fce1f885d6bb4a2b">&#9670;&#160;</a></span>rjust()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class CharT, class TraitsT, class AllocatorT&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classpcs_1_1_cpp_string_t.html">CppStringT</a> <a class="el" href="classpcs_1_1_cpp_string_t.html">pcs::CppStringT</a>&lt; CharT, TraitsT, AllocatorT &gt;::rjust </td>
          <td>(</td>
          <td class="paramtype">const size_type</td>          <td class="paramname"><span class="paramname"><em>width</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const value_type</td>          <td class="paramname"><span class="paramname"><em>fillch</em></span><span class="paramdefsep"> = </span><span class="paramdefval">value_type('&#160;')</span>&#160;) const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span><span class="mlabel nodiscard">nodiscard</span><span class="mlabel noexcept">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns the string right justified in a string of length width. </p>
<p>Padding is done using the specified fillchar (default is an ASCII space). The original string is returned if width is less than or equal to len(s). </p>

</div>
</div>
<a id="a61674ee4e97038d82ea7ecc30b1761f6" name="a61674ee4e97038d82ea7ecc30b1761f6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a61674ee4e97038d82ea7ecc30b1761f6">&#9670;&#160;</a></span>rpartition()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class CharT, class TraitsT, class AllocatorT&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::vector&lt; <a class="el" href="classpcs_1_1_cpp_string_t.html">CppStringT</a> &gt; <a class="el" href="classpcs_1_1_cpp_string_t.html">pcs::CppStringT</a>&lt; CharT, TraitsT, AllocatorT &gt;::rpartition </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classpcs_1_1_cpp_string_t.html">CppStringT</a>&lt; CharT, TraitsT, AllocatorT &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>sep</em></span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span><span class="mlabel nodiscard">nodiscard</span><span class="mlabel noexcept">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Splits the string at the last occurrence of sep, and returns a 3-items vector containing the part before the separator, the separator itself, and the part after the separator. </p>
<p>If the separator is not found, returns a 3-items vector containing the string itself, followed by two empty strings. </p>

</div>
</div>
<a id="a8111cd357773d304fbb496571d7ee6be" name="a8111cd357773d304fbb496571d7ee6be"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8111cd357773d304fbb496571d7ee6be">&#9670;&#160;</a></span>rsplit() <span class="overload">[1/4]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class CharT, class TraitsT, class AllocatorT&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::vector&lt; <a class="el" href="classpcs_1_1_cpp_string_t.html">CppStringT</a> &gt; <a class="el" href="classpcs_1_1_cpp_string_t.html">pcs::CppStringT</a>&lt; CharT, TraitsT, AllocatorT &gt;::rsplit </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span><span class="mlabel nodiscard">nodiscard</span><span class="mlabel noexcept">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns a vector of the words in the whole string, as seperated with whitespace strings. </p>
<p>Notice: consecutive whitespaces are each regarded as a single separator. So, they each separate empty strings. </p>

<p class="reference">Referenced by <a class="el" href="#a3aa66706e268bd570a0084d70dff5cde">pcs::CppStringT&lt; char &gt;::rsplit()</a>.</p>

</div>
</div>
<a id="a0419f46de6fa532372f3b97b4927ebab" name="a0419f46de6fa532372f3b97b4927ebab"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0419f46de6fa532372f3b97b4927ebab">&#9670;&#160;</a></span>rsplit() <span class="overload">[2/4]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class CharT, class TraitsT, class AllocatorT&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::vector&lt; <a class="el" href="classpcs_1_1_cpp_string_t.html">CppStringT</a> &gt; <a class="el" href="classpcs_1_1_cpp_string_t.html">pcs::CppStringT</a>&lt; CharT, TraitsT, AllocatorT &gt;::rsplit </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classpcs_1_1_cpp_string_t.html">CppStringT</a>&lt; CharT, TraitsT, AllocatorT &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>sep</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span><span class="mlabel nodiscard">nodiscard</span><span class="mlabel noexcept">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns a vector of the words in the whole string, using sep as the delimiter string. </p>

</div>
</div>
<a id="ab0ace502f0b3026fefd2942a1e8a0456" name="ab0ace502f0b3026fefd2942a1e8a0456"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab0ace502f0b3026fefd2942a1e8a0456">&#9670;&#160;</a></span>rsplit() <span class="overload">[3/4]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class CharT, class TraitsT, class AllocatorT&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::vector&lt; <a class="el" href="classpcs_1_1_cpp_string_t.html">CppStringT</a> &gt; <a class="el" href="classpcs_1_1_cpp_string_t.html">pcs::CppStringT</a>&lt; CharT, TraitsT, AllocatorT &gt;::rsplit </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classpcs_1_1_cpp_string_t.html">CppStringT</a>&lt; CharT, TraitsT, AllocatorT &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>sep</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const size_type</td>          <td class="paramname"><span class="paramname"><em>maxsplit</em></span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span><span class="mlabel nodiscard">nodiscard</span><span class="mlabel noexcept">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns a vector of the words in the string, using sep as the delimiter string. At most maxsplit splits are done, the rightmost ones. </p>

</div>
</div>
<a id="a3aa66706e268bd570a0084d70dff5cde" name="a3aa66706e268bd570a0084d70dff5cde"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3aa66706e268bd570a0084d70dff5cde">&#9670;&#160;</a></span>rsplit() <span class="overload">[4/4]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class CharT, class TraitsT, class AllocatorT&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::vector&lt; <a class="el" href="classpcs_1_1_cpp_string_t.html">CppStringT</a> &gt; <a class="el" href="classpcs_1_1_cpp_string_t.html">pcs::CppStringT</a>&lt; CharT, TraitsT, AllocatorT &gt;::rsplit </td>
          <td>(</td>
          <td class="paramtype">const size_type</td>          <td class="paramname"><span class="paramname"><em>maxsplit</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span><span class="mlabel nodiscard">nodiscard</span><span class="mlabel noexcept">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns a vector of the words in the string, as seperated with whitespace strings. At most maxsplit splits are done, the rightmost ones. </p>

</div>
</div>
<a id="a86f8c78b2eeb3541fb6b56b4f4ac237b" name="a86f8c78b2eeb3541fb6b56b4f4ac237b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a86f8c78b2eeb3541fb6b56b4f4ac237b">&#9670;&#160;</a></span>rstrip() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class CharT, class TraitsT, class AllocatorT&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classpcs_1_1_cpp_string_t.html">CppStringT</a> <a class="el" href="classpcs_1_1_cpp_string_t.html">pcs::CppStringT</a>&lt; CharT, TraitsT, AllocatorT &gt;::rstrip </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span><span class="mlabel nodiscard">nodiscard</span><span class="mlabel noexcept">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns a copy of the string with trailing whitespaces removed. </p>

<p class="reference">Referenced by <a class="el" href="#a12bc043347f555b4701e0c70d972058d">pcs::CppStringT&lt; char &gt;::strip()</a>, and <a class="el" href="#a02919129cdf158e75eae1e9815a071bf">pcs::CppStringT&lt; char &gt;::strip()</a>.</p>

</div>
</div>
<a id="a89e850d45d6dec167e763cf748a06971" name="a89e850d45d6dec167e763cf748a06971"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a89e850d45d6dec167e763cf748a06971">&#9670;&#160;</a></span>rstrip() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class CharT, class TraitsT, class AllocatorT&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classpcs_1_1_cpp_string_t.html">CppStringT</a> <a class="el" href="classpcs_1_1_cpp_string_t.html">pcs::CppStringT</a>&lt; CharT, TraitsT, AllocatorT &gt;::rstrip </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classpcs_1_1_cpp_string_t.html">CppStringT</a>&lt; CharT, TraitsT, AllocatorT &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>removedchars</em></span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span><span class="mlabel nodiscard">nodiscard</span><span class="mlabel noexcept">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns a copy of the string with trailing characters removed. </p>
<p>The passed string specifies the set of characters to be removed. The chars argument is not a prefix; rather, all combinations of its values are stripped. To remove a suffix, rather call method '<a class="el" href="#ad6a8dc124ab8b7cab1cb328240763ed0" title="If the string ends with the suffix string, returns a new string with the suffix removed....">removesuffix()</a>'. </p>

</div>
</div>
<a id="a7ca47096b03baa0091c3b0349d210931" name="a7ca47096b03baa0091c3b0349d210931"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7ca47096b03baa0091c3b0349d210931">&#9670;&#160;</a></span>split() <span class="overload">[1/4]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class CharT, class TraitsT, class AllocatorT&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::vector&lt; <a class="el" href="classpcs_1_1_cpp_string_t.html">CppStringT</a> &gt; <a class="el" href="classpcs_1_1_cpp_string_t.html">pcs::CppStringT</a>&lt; CharT, TraitsT, AllocatorT &gt;::split </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span><span class="mlabel nodiscard">nodiscard</span><span class="mlabel noexcept">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns a vector of the words in the whole string, as seperated with whitespace strings. </p>
<p>Notice: consecutive whitespaces are each regarded as a single separator. So, they each separate empty strings. </p>

<p class="reference">Referenced by <a class="el" href="#a8111cd357773d304fbb496571d7ee6be">pcs::CppStringT&lt; char &gt;::rsplit()</a>, <a class="el" href="#a0419f46de6fa532372f3b97b4927ebab">pcs::CppStringT&lt; char &gt;::rsplit()</a>, <a class="el" href="#a8fa2afe84d7fc26f96bbd55f4266df2a">pcs::CppStringT&lt; char &gt;::split()</a>, and <a class="el" href="#a179634aafb049e8604ca78f813684a28">pcs::CppStringT&lt; char &gt;::title()</a>.</p>

</div>
</div>
<a id="acf4d923cfed55cfd90cf12651ce0ac3d" name="acf4d923cfed55cfd90cf12651ce0ac3d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#acf4d923cfed55cfd90cf12651ce0ac3d">&#9670;&#160;</a></span>split() <span class="overload">[2/4]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class CharT, class TraitsT, class AllocatorT&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::vector&lt; <a class="el" href="classpcs_1_1_cpp_string_t.html">CppStringT</a> &gt; <a class="el" href="classpcs_1_1_cpp_string_t.html">pcs::CppStringT</a>&lt; CharT, TraitsT, AllocatorT &gt;::split </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classpcs_1_1_cpp_string_t.html">CppStringT</a>&lt; CharT, TraitsT, AllocatorT &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>sep</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span><span class="mlabel nodiscard">nodiscard</span><span class="mlabel noexcept">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns a vector of the words in the whole string, using sep as the delimiter string. </p>
<p>Notice: consecutive delimiters are not grouped together and are deemed to delimit empty strings (for example, "1,,2".split(",") returns {"1", "", "2"}). The sep argument may consist of multiple characters (for example, "1&lt;&gt;2&lt;&gt;3".split("&lt;&gt;") returns {"1", "2", "3"]). Splitting an empty string with a specified separator returns {""}. </p>

</div>
</div>
<a id="a55a3fa32de834f644ac28d7c2495fa77" name="a55a3fa32de834f644ac28d7c2495fa77"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a55a3fa32de834f644ac28d7c2495fa77">&#9670;&#160;</a></span>split() <span class="overload">[3/4]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class CharT, class TraitsT, class AllocatorT&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::vector&lt; <a class="el" href="classpcs_1_1_cpp_string_t.html">CppStringT</a> &gt; <a class="el" href="classpcs_1_1_cpp_string_t.html">pcs::CppStringT</a>&lt; CharT, TraitsT, AllocatorT &gt;::split </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classpcs_1_1_cpp_string_t.html">CppStringT</a>&lt; CharT, TraitsT, AllocatorT &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>sep</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const size_type</td>          <td class="paramname"><span class="paramname"><em>maxsplit</em></span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span><span class="mlabel nodiscard">nodiscard</span><span class="mlabel noexcept">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns a vector of the words in the string, using sep as the delimiter string. At most maxsplit splits are done, the leftmost ones. </p>

</div>
</div>
<a id="a8fa2afe84d7fc26f96bbd55f4266df2a" name="a8fa2afe84d7fc26f96bbd55f4266df2a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8fa2afe84d7fc26f96bbd55f4266df2a">&#9670;&#160;</a></span>split() <span class="overload">[4/4]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class CharT, class TraitsT, class AllocatorT&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::vector&lt; <a class="el" href="classpcs_1_1_cpp_string_t.html">CppStringT</a> &gt; <a class="el" href="classpcs_1_1_cpp_string_t.html">pcs::CppStringT</a>&lt; CharT, TraitsT, AllocatorT &gt;::split </td>
          <td>(</td>
          <td class="paramtype">const size_type</td>          <td class="paramname"><span class="paramname"><em>maxsplit</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span><span class="mlabel nodiscard">nodiscard</span><span class="mlabel noexcept">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns a vector of the words in the string, as seperated with whitespace strings. At most maxsplit splits are done, the leftmost ones. </p>

</div>
</div>
<a id="a0bd53df14569c307b5ca50a2e1e62960" name="a0bd53df14569c307b5ca50a2e1e62960"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0bd53df14569c307b5ca50a2e1e62960">&#9670;&#160;</a></span>splitlines()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class CharT, class TraitsT, class AllocatorT&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::vector&lt; <a class="el" href="classpcs_1_1_cpp_string_t.html">CppStringT</a> &gt; <a class="el" href="classpcs_1_1_cpp_string_t.html">pcs::CppStringT</a>&lt; CharT, TraitsT, AllocatorT &gt;::splitlines </td>
          <td>(</td>
          <td class="paramtype">const bool</td>          <td class="paramname"><span class="paramname"><em>keep_end</em></span><span class="paramdefsep"> = </span><span class="paramdefval">false</span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span><span class="mlabel nodiscard">nodiscard</span><span class="mlabel noexcept">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Return a list of the lines in the string, breaking at line boundaries. </p>
<p>Line breaks are not included in the resulting list unless keepends is given and true.</p>
<p>This method splits on the following line boundaries. In particular, the boundaries are a superset of universal newlines: '<br  />
' Line Feed '\r' Carriage Return '\r<br  />
' Carriage Return + Line Feed '\v' or '\x0b' Line Tabulation '\f' or '\x0c' Form Feed '\x1c' File Separator '\x1d' Group Separator '\x1e' Record Separator Next separators values, detected by Python method <a class="el" href="#a0bd53df14569c307b5ca50a2e1e62960" title="Return a list of the lines in the string, breaking at line boundaries.">splitlines()</a>, are currently NOT detected by CppStrings '\x85' Next Line (C1 Control Code) '\u2028' Line Separator '\u2029' Paragraph Separator </p>

</div>
</div>
<a id="ae2f755ae7903586a2086b7b7f943d96e" name="ae2f755ae7903586a2086b7b7f943d96e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae2f755ae7903586a2086b7b7f943d96e">&#9670;&#160;</a></span>startswith() <span class="overload">[1/4]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class CharT, class TraitsT, class AllocatorT&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const bool <a class="el" href="classpcs_1_1_cpp_string_t.html">pcs::CppStringT</a>&lt; CharT, TraitsT, AllocatorT &gt;::startswith </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classpcs_1_1_cpp_string_t.html">CppStringT</a>&lt; CharT, TraitsT, AllocatorT &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>prefix</em></span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span><span class="mlabel nodiscard">nodiscard</span><span class="mlabel noexcept">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns true if the string starts with the specified prefix, otherwise returns false. Test runs on the whole string. </p>

</div>
</div>
<a id="ad2cfcc7bd22736ebd9f91f04e6a42f8c" name="ad2cfcc7bd22736ebd9f91f04e6a42f8c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad2cfcc7bd22736ebd9f91f04e6a42f8c">&#9670;&#160;</a></span>startswith() <span class="overload">[2/4]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class CharT, class TraitsT, class AllocatorT&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const bool <a class="el" href="classpcs_1_1_cpp_string_t.html">pcs::CppStringT</a>&lt; CharT, TraitsT, AllocatorT &gt;::startswith </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classpcs_1_1_cpp_string_t.html">CppStringT</a>&lt; CharT, TraitsT, AllocatorT &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>prefix</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const size_type</td>          <td class="paramname"><span class="paramname"><em>start</em></span>&#160;) const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span><span class="mlabel nodiscard">nodiscard</span><span class="mlabel noexcept">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns true if the string starts with the specified prefix, otherwise returns false. Test begins at start position and stops at end of string. </p>

</div>
</div>
<a id="a5a131c385a01ccc5410d4cffa55cf700" name="a5a131c385a01ccc5410d4cffa55cf700"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5a131c385a01ccc5410d4cffa55cf700">&#9670;&#160;</a></span>startswith() <span class="overload">[3/4]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class CharT, class TraitsT, class AllocatorT&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const bool <a class="el" href="classpcs_1_1_cpp_string_t.html">pcs::CppStringT</a>&lt; CharT, TraitsT, AllocatorT &gt;::startswith </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classpcs_1_1_cpp_string_t.html">CppStringT</a>&lt; CharT, TraitsT, AllocatorT &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>prefix</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const size_type</td>          <td class="paramname"><span class="paramname"><em>start</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const size_type</td>          <td class="paramname"><span class="paramname"><em>end</em></span>&#160;) const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span><span class="mlabel nodiscard">nodiscard</span><span class="mlabel noexcept">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns true if the string starts with the specified prefix, otherwise returns false. Test begins at start position and stops at end position. </p>

<p class="reference">Referenced by <a class="el" href="#a058704b7f4538ec9e1798c5348d37c7a">pcs::CppStringT&lt; char &gt;::removeprefix()</a>, <a class="el" href="#ad2cfcc7bd22736ebd9f91f04e6a42f8c">pcs::CppStringT&lt; char &gt;::startswith()</a>, and <a class="el" href="#ab2b293c5f1b55af52ceb75b8f7e4d42e">pcs::CppStringT&lt; char &gt;::startswith_n()</a>.</p>

</div>
</div>
<a id="a326eb96e19c3559a84af86ff1bf54aa4" name="a326eb96e19c3559a84af86ff1bf54aa4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a326eb96e19c3559a84af86ff1bf54aa4">&#9670;&#160;</a></span>startswith() <span class="overload">[4/4]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class CharT, class TraitsT, class AllocatorT&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const bool <a class="el" href="classpcs_1_1_cpp_string_t.html">pcs::CppStringT</a>&lt; CharT, TraitsT, AllocatorT &gt;::startswith </td>
          <td>(</td>
          <td class="paramtype">const std::initializer_list&lt; <a class="el" href="classpcs_1_1_cpp_string_t.html">CppStringT</a>&lt; CharT, TraitsT, AllocatorT &gt; &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>prefixes</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const size_type</td>          <td class="paramname"><span class="paramname"><em>start</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const size_type</td>          <td class="paramname"><span class="paramname"><em>end</em></span>&#160;) const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span><span class="mlabel nodiscard">nodiscard</span><span class="mlabel noexcept">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns true if the string starts with any of the specified prefixes, otherwise returns false. Test begins at start position and stops at end of string. </p>

</div>
</div>
<a id="ae0865e2c7f8a4871804bf71c1c982dc6" name="ae0865e2c7f8a4871804bf71c1c982dc6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae0865e2c7f8a4871804bf71c1c982dc6">&#9670;&#160;</a></span>startswith_n() <span class="overload">[1/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class CharT, class TraitsT, class AllocatorT&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const bool <a class="el" href="classpcs_1_1_cpp_string_t.html">pcs::CppStringT</a>&lt; CharT, TraitsT, AllocatorT &gt;::startswith_n </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classpcs_1_1_cpp_string_t.html">CppStringT</a>&lt; CharT, TraitsT, AllocatorT &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>prefix</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const size_type</td>          <td class="paramname"><span class="paramname"><em>count</em></span>&#160;) const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span><span class="mlabel nodiscard">nodiscard</span><span class="mlabel noexcept">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns true if the string starts with the specified suffix, otherwise returns false. Test begins at position 0 and stops after count positions. </p>

</div>
</div>
<a id="a3b7955f9c7f9452a6a025caaaf0e6d73" name="a3b7955f9c7f9452a6a025caaaf0e6d73"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3b7955f9c7f9452a6a025caaaf0e6d73">&#9670;&#160;</a></span>startswith_n() <span class="overload">[2/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class CharT, class TraitsT, class AllocatorT&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const bool <a class="el" href="classpcs_1_1_cpp_string_t.html">pcs::CppStringT</a>&lt; CharT, TraitsT, AllocatorT &gt;::startswith_n </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classpcs_1_1_cpp_string_t.html">CppStringT</a>&lt; CharT, TraitsT, AllocatorT &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>prefix</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const size_type</td>          <td class="paramname"><span class="paramname"><em>start</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const size_type</td>          <td class="paramname"><span class="paramname"><em>count</em></span>&#160;) const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span><span class="mlabel nodiscard">nodiscard</span><span class="mlabel noexcept">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns true if the string starts with the specified suffix, otherwise returns false. Test begins at start position and stops after count positions. </p>

</div>
</div>
<a id="ab2b293c5f1b55af52ceb75b8f7e4d42e" name="ab2b293c5f1b55af52ceb75b8f7e4d42e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab2b293c5f1b55af52ceb75b8f7e4d42e">&#9670;&#160;</a></span>startswith_n() <span class="overload">[3/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class CharT, class TraitsT, class AllocatorT&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const bool <a class="el" href="classpcs_1_1_cpp_string_t.html">pcs::CppStringT</a>&lt; CharT, TraitsT, AllocatorT &gt;::startswith_n </td>
          <td>(</td>
          <td class="paramtype">const std::initializer_list&lt; <a class="el" href="classpcs_1_1_cpp_string_t.html">CppStringT</a>&lt; CharT, TraitsT, AllocatorT &gt; &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>prefix</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const size_type</td>          <td class="paramname"><span class="paramname"><em>start</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const size_type</td>          <td class="paramname"><span class="paramname"><em>count</em></span>&#160;) const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span><span class="mlabel nodiscard">nodiscard</span><span class="mlabel noexcept">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns true if the string starts with any of the specified suffixes, otherwise returns false. Test begins at start position and stops after count positions. </p>

</div>
</div>
<a id="a12bc043347f555b4701e0c70d972058d" name="a12bc043347f555b4701e0c70d972058d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a12bc043347f555b4701e0c70d972058d">&#9670;&#160;</a></span>strip() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class CharT, class TraitsT, class AllocatorT&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classpcs_1_1_cpp_string_t.html">CppStringT</a> <a class="el" href="classpcs_1_1_cpp_string_t.html">pcs::CppStringT</a>&lt; CharT, TraitsT, AllocatorT &gt;::strip </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span><span class="mlabel nodiscard">nodiscard</span><span class="mlabel noexcept">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns a copy of the string with the leading and trailing whitespaces removed. </p>

</div>
</div>
<a id="a02919129cdf158e75eae1e9815a071bf" name="a02919129cdf158e75eae1e9815a071bf"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a02919129cdf158e75eae1e9815a071bf">&#9670;&#160;</a></span>strip() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class CharT, class TraitsT, class AllocatorT&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classpcs_1_1_cpp_string_t.html">CppStringT</a> <a class="el" href="classpcs_1_1_cpp_string_t.html">pcs::CppStringT</a>&lt; CharT, TraitsT, AllocatorT &gt;::strip </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classpcs_1_1_cpp_string_t.html">CppStringT</a>&lt; CharT, TraitsT, AllocatorT &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>removedchars</em></span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span><span class="mlabel nodiscard">nodiscard</span><span class="mlabel noexcept">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns a copy of the string with the leading and trailing characters removed. </p>
<p>The passed string specifies the set of characters to be removed. The chars argument is not a prefix; rather, all combinations of its values are stripped. </p>

</div>
</div>
<a id="a9debc70420a3fbc7722e3111aeccd819" name="a9debc70420a3fbc7722e3111aeccd819"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9debc70420a3fbc7722e3111aeccd819">&#9670;&#160;</a></span>substr()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class CharT, class TraitsT, class AllocatorT&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classpcs_1_1_cpp_string_t.html">CppStringT</a> <a class="el" href="classpcs_1_1_cpp_string_t.html">pcs::CppStringT</a>&lt; CharT, TraitsT, AllocatorT &gt;::substr </td>
          <td>(</td>
          <td class="paramtype">const size_type</td>          <td class="paramname"><span class="paramname"><em>start</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const size_type</td>          <td class="paramname"><span class="paramname"><em>count</em></span><span class="paramdefsep"> = </span><span class="paramdefval">-1</span>&#160;) const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span><span class="mlabel nodiscard">nodiscard</span><span class="mlabel noexcept">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns a copy of the string, starting at index start and ending after count characters. </p>

<p class="reference">Referenced by <a class="el" href="#a0674e29327353aabf83d0e207fed31ed">pcs::CppStringT&lt; char &gt;::contains()</a>, <a class="el" href="#a031b05f290f589b2df52bb84252c27c7">pcs::CppStringT&lt; char &gt;::contains_n()</a>, <a class="el" href="#a7beda74b4d5092845a970d51d01fe4bf">pcs::CppStringT&lt; char &gt;::count()</a>, <a class="el" href="#a6b23210d7d5eb07c9f942d62cc76b05e">pcs::CppStringT&lt; char &gt;::endswith()</a>, <a class="el" href="#a42f1e87d7f1903536ee79aa058d5c867">pcs::CppStringT&lt; char &gt;::endswith()</a>, <a class="el" href="#a87b25fce2a05421efd718c599a784a09">pcs::CppStringT&lt; char &gt;::endswith()</a>, <a class="el" href="#ac4c9351bb52eb9a62fa7fb2e2d5f054d">pcs::CppStringT&lt; char &gt;::find_n()</a>, <a class="el" href="#a1fa8862a5f306553d6f0dae7e76fce83">pcs::CppStringT&lt; char &gt;::operator()()</a>, <a class="el" href="#ac5f88b0fc1f33cda23c30cb1f3bc560f">pcs::CppStringT&lt; char &gt;::partition()</a>, <a class="el" href="#a058704b7f4538ec9e1798c5348d37c7a">pcs::CppStringT&lt; char &gt;::removeprefix()</a>, <a class="el" href="#ad6a8dc124ab8b7cab1cb328240763ed0">pcs::CppStringT&lt; char &gt;::removesuffix()</a>, <a class="el" href="#ad4f39683db649aa8a65907268c499f02">pcs::CppStringT&lt; char &gt;::replace()</a>, <a class="el" href="#af363308ba741b267641e1aa35669d603">pcs::CppStringT&lt; char &gt;::rfind()</a>, <a class="el" href="#a61674ee4e97038d82ea7ecc30b1761f6">pcs::CppStringT&lt; char &gt;::rpartition()</a>, <a class="el" href="#ab0ace502f0b3026fefd2942a1e8a0456">pcs::CppStringT&lt; char &gt;::rsplit()</a>, <a class="el" href="#a55a3fa32de834f644ac28d7c2495fa77">pcs::CppStringT&lt; char &gt;::split()</a>, <a class="el" href="#a5a131c385a01ccc5410d4cffa55cf700">pcs::CppStringT&lt; char &gt;::startswith()</a>, <a class="el" href="#a326eb96e19c3559a84af86ff1bf54aa4">pcs::CppStringT&lt; char &gt;::startswith()</a>, <a class="el" href="#ae0865e2c7f8a4871804bf71c1c982dc6">pcs::CppStringT&lt; char &gt;::startswith_n()</a>, <a class="el" href="#a3b7955f9c7f9452a6a025caaaf0e6d73">pcs::CppStringT&lt; char &gt;::startswith_n()</a>, and <a class="el" href="#ad3d2b94f37325096205e399b95e9fc5d">pcs::CppStringT&lt; char &gt;::zfill()</a>.</p>

</div>
</div>
<a id="a6ab02b4d1c8093a5dfc089a45427f63c" name="a6ab02b4d1c8093a5dfc089a45427f63c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6ab02b4d1c8093a5dfc089a45427f63c">&#9670;&#160;</a></span>swapcase()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class CharT, class TraitsT, class AllocatorT&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classpcs_1_1_cpp_string_t.html">CppStringT</a> <a class="el" href="classpcs_1_1_cpp_string_t.html">pcs::CppStringT</a>&lt; CharT, TraitsT, AllocatorT &gt;::swapcase </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span><span class="mlabel nodiscard">nodiscard</span><span class="mlabel noexcept">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns a copy of the string with uppercase characters converted to lowercase and vice versa. </p>
<p>Note that it is not necessarily true that s.swapcase().<a class="el" href="#a6ab02b4d1c8093a5dfc089a45427f63c" title="Returns a copy of the string with uppercase characters converted to lowercase and vice versa.">swapcase()</a> == s. </p>

</div>
</div>
<a id="a179634aafb049e8604ca78f813684a28" name="a179634aafb049e8604ca78f813684a28"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a179634aafb049e8604ca78f813684a28">&#9670;&#160;</a></span>title()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class CharT, class TraitsT, class AllocatorT&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classpcs_1_1_cpp_string_t.html">CppStringT</a> <a class="el" href="classpcs_1_1_cpp_string_t.html">pcs::CppStringT</a>&lt; CharT, TraitsT, AllocatorT &gt;::title </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span><span class="mlabel nodiscard">nodiscard</span><span class="mlabel noexcept">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns a titlecased copy of the string where words start with an uppercase character and the remaining characters are lowercase. </p>

<p class="reference">Referenced by <a class="el" href="#ad72611f339c2b9027a72fa26f25748c3">pcs::CppStringT&lt; char &gt;::istitle()</a>.</p>

</div>
</div>
<a id="a2a8c1e78b93da9a0abe471c7a8d85090" name="a2a8c1e78b93da9a0abe471c7a8d85090"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2a8c1e78b93da9a0abe471c7a8d85090">&#9670;&#160;</a></span>translate()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class CharT, class TraitsT, class AllocatorT&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classpcs_1_1_cpp_string_t.html">CppStringT</a> <a class="el" href="classpcs_1_1_cpp_string_t.html">pcs::CppStringT</a>&lt; CharT, TraitsT, AllocatorT &gt;::translate </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classpcs_1_1_cpp_string_t_1_1_trans_table.html">TransTable</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>table</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span><span class="mlabel nodiscard">nodiscard</span><span class="mlabel noexcept">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns a copy of the string in which each character has been mapped through the given translation table. </p>
<p>The table must be of type <a class="el" href="classpcs_1_1_cpp_string_t_1_1_trans_table.html" title="The internal class of translation tables, used with methods CppStringT::maketrans and CppStringT::tra...">CppStringT::TransTable</a>. When a character to be translated is not available as an entry in the tranlation table, it is set as is in the resulting string. </p>

</div>
</div>
<a id="a689d2de98f28d131bb0c8b3c87f2f120" name="a689d2de98f28d131bb0c8b3c87f2f120"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a689d2de98f28d131bb0c8b3c87f2f120">&#9670;&#160;</a></span>upper() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class CharT, class TraitsT, class AllocatorT&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classpcs_1_1_cpp_string_t.html">CppStringT</a> &amp; <a class="el" href="classpcs_1_1_cpp_string_t.html">pcs::CppStringT</a>&lt; CharT, TraitsT, AllocatorT &gt;::upper </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span><span class="mlabel noexcept">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>In-place replaces all characters of the string with their uppercase conversion. Returns a reference to string. </p>
<p>Notice: uses the currently set std::locale, which is the "C" one by default or any other one as previously set by the user. </p>

<p class="reference">Referenced by <a class="el" href="#a689d2de98f28d131bb0c8b3c87f2f120">pcs::CppStringT&lt; char &gt;::upper()</a>.</p>

</div>
</div>
<a id="af5ff8cdba1d90516915e20f93567a9a9" name="af5ff8cdba1d90516915e20f93567a9a9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af5ff8cdba1d90516915e20f93567a9a9">&#9670;&#160;</a></span>upper() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class CharT, class TraitsT, class AllocatorT&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const value_type <a class="el" href="classpcs_1_1_cpp_string_t.html">pcs::CppStringT</a>&lt; CharT, TraitsT, AllocatorT &gt;::upper </td>
          <td>(</td>
          <td class="paramtype">const value_type</td>          <td class="paramname"><span class="paramname"><em>ch</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span><span class="mlabel static">static</span><span class="mlabel nodiscard">nodiscard</span><span class="mlabel noexcept">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns uppercase conversion of the character. </p>
<p>Notice: uses the currently set std::locale, which is the "C" one by default or any other one as previously set by the user. </p>

</div>
</div>
<a id="ad3d2b94f37325096205e399b95e9fc5d" name="ad3d2b94f37325096205e399b95e9fc5d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad3d2b94f37325096205e399b95e9fc5d">&#9670;&#160;</a></span>zfill()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class CharT, class TraitsT, class AllocatorT&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classpcs_1_1_cpp_string_t.html">CppStringT</a> <a class="el" href="classpcs_1_1_cpp_string_t.html">pcs::CppStringT</a>&lt; CharT, TraitsT, AllocatorT &gt;::zfill </td>
          <td>(</td>
          <td class="paramtype">const size_type</td>          <td class="paramname"><span class="paramname"><em>width</em></span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span><span class="mlabel nodiscard">nodiscard</span><span class="mlabel noexcept">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns a copy of the string left filled with ASCII '0' digits to make a string of length width. </p>
<p>A leading sign prefix ('+'/'-') is handled by inserting the padding after the sign character rather than before. The original string is returned if width is less than or equal to len(s). </p>

</div>
</div>
<hr/>The documentation for this class was generated from the following file:<ul>
<li><b>cppstrings.h</b></li>
</ul>
</div><!-- contents -->
</div><!-- doc-content -->
<div id="page-nav" class="page-nav-panel">
<div id="page-nav-resize-handle"></div>
<div id="page-nav-tree">
<div id="page-nav-contents">
</div><!-- page-nav-contents -->
</div><!-- page-nav-tree -->
</div><!-- page-nav -->
</div><!-- container -->
<!-- start footer part -->
<div id="nav-path" class="navpath"><!-- id is needed for treeview function! -->
  <ul>
    <li class="navelem"><a href="namespacepcs.html">pcs</a></li><li class="navelem"><a href="classpcs_1_1_cpp_string_t.html">CppStringT</a></li>
    <li class="footer">Generated on <span class="timestamp"></span> for cpp-strings by <a href="https://www.doxygen.org/index.html"><img class="footer" src="doxygen.svg" width="104" height="31" alt="doxygen"/></a> 1.14.0 </li>
  </ul>
</div>
</body>
</html>
